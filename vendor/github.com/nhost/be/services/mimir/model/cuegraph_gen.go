// Code generated by github.com/nhost/be/tools/cuegraph, DO NOT EDIT.

package model

type Matcher[T any] interface {
	Matches(T) bool
}

func all[T any, U Matcher[T]](list []U, element T) bool {
	for _, e := range list {
		if !e.Matches(element) {
			return false
		}
	}
	return true
}

func or[T any, U Matcher[T]](list []U, element T) bool {
	for _, e := range list {
		if e.Matches(element) {
			return true
		}
	}
	return false
}

func contains[T comparable](slice []T, item T) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

type GenericComparisonExp[T comparable] struct {
	Eq  *T  `json:"_eq,omitempty"`
	Neq *T  `json:"_neq,omitempty"`
	In  []T `json:"_in,omitempty"`
	Nin []T `json:"_nin,omitempty"`
}

func (exp *GenericComparisonExp[T]) Matches(o T) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}

type (
	ConfigIntComparisonExp   = GenericComparisonExp[int]
	ConfigInt8ComparisonExp  = GenericComparisonExp[int8]
	ConfigInt16ComparisonExp = GenericComparisonExp[int16]
	ConfigInt32ComparisonExp = GenericComparisonExp[int32]
	ConfigInt64ComparisonExp = GenericComparisonExp[int64]
)

type (
	ConfigUintComparisonExp   = GenericComparisonExp[uint]
	ConfigUint8ComparisonExp  = GenericComparisonExp[uint8]
	ConfigUint16ComparisonExp = GenericComparisonExp[uint16]
	ConfigUint32ComparisonExp = GenericComparisonExp[uint32]
	ConfigUint64ComparisonExp = GenericComparisonExp[uint64]
)

type ConfigStringComparisonExp = GenericComparisonExp[string]

type ConfigBooleanComparisonExp = GenericComparisonExp[bool]

type ConfigFloatComparisonExp = GenericComparisonExp[float64]

type ConfigAuth struct {
	Version      string                  `json:"version,omitempty"`
	Redirections *ConfigAuthRedirections `json:"redirections,omitempty"`
	SignUp       *ConfigAuthSignUp       `json:"signUp,omitempty"`
	User         *ConfigAuthUser         `json:"user,omitempty"`
	Session      *ConfigAuthSession      `json:"session,omitempty"`
	Method       *ConfigAuthMethod       `json:"method,omitempty"`
	Totp         *ConfigAuthTotp         `json:"totp,omitempty"`
}

func (o *ConfigAuth) GetVersion() string {
	if o == nil {
		o = &ConfigAuth{}
	}

	return o.Version
}

func (o *ConfigAuth) GetRedirections() *ConfigAuthRedirections {
	if o == nil {
		return nil
	}

	return o.Redirections
}

func (o *ConfigAuth) GetSignUp() *ConfigAuthSignUp {
	if o == nil {
		return nil
	}

	return o.SignUp
}

func (o *ConfigAuth) GetUser() *ConfigAuthUser {
	if o == nil {
		return nil
	}

	return o.User
}

func (o *ConfigAuth) GetSession() *ConfigAuthSession {
	if o == nil {
		return nil
	}

	return o.Session
}

func (o *ConfigAuth) GetMethod() *ConfigAuthMethod {
	if o == nil {
		return nil
	}

	return o.Method
}

func (o *ConfigAuth) GetTotp() *ConfigAuthTotp {
	if o == nil {
		return nil
	}

	return o.Totp
}

type ConfigAuthUpdateInput struct {
	Version      *string                            `json:"version,omitempty"`
	Redirections *ConfigAuthRedirectionsUpdateInput `json:"redirections,omitempty"`
	SignUp       *ConfigAuthSignUpUpdateInput       `json:"signUp,omitempty"`
	User         *ConfigAuthUserUpdateInput         `json:"user,omitempty"`
	Session      *ConfigAuthSessionUpdateInput      `json:"session,omitempty"`
	Method       *ConfigAuthMethodUpdateInput       `json:"method,omitempty"`
	Totp         *ConfigAuthTotpUpdateInput         `json:"totp,omitempty"`
}

func (s *ConfigAuth) Update(v *ConfigAuthUpdateInput) {
	if v == nil {
		return
	}
	if v.Version != nil {
		s.Version = *v.Version
	}
	if v.Redirections != nil {
		if s.Redirections == nil {
			s.Redirections = &ConfigAuthRedirections{}
		}
		s.Redirections.Update(v.Redirections)
	}
	if v.SignUp != nil {
		if s.SignUp == nil {
			s.SignUp = &ConfigAuthSignUp{}
		}
		s.SignUp.Update(v.SignUp)
	}
	if v.User != nil {
		if s.User == nil {
			s.User = &ConfigAuthUser{}
		}
		s.User.Update(v.User)
	}
	if v.Session != nil {
		if s.Session == nil {
			s.Session = &ConfigAuthSession{}
		}
		s.Session.Update(v.Session)
	}
	if v.Method != nil {
		if s.Method == nil {
			s.Method = &ConfigAuthMethod{}
		}
		s.Method.Update(v.Method)
	}
	if v.Totp != nil {
		if s.Totp == nil {
			s.Totp = &ConfigAuthTotp{}
		}
		s.Totp.Update(v.Totp)
	}
}

type ConfigAuthInsertInput struct {
	Version      *string                            `json:"version,omitempty"`
	Redirections *ConfigAuthRedirectionsInsertInput `json:"redirections,omitempty"`
	SignUp       *ConfigAuthSignUpInsertInput       `json:"signUp,omitempty"`
	User         *ConfigAuthUserInsertInput         `json:"user,omitempty"`
	Session      *ConfigAuthSessionInsertInput      `json:"session,omitempty"`
	Method       *ConfigAuthMethodInsertInput       `json:"method,omitempty"`
	Totp         *ConfigAuthTotpInsertInput         `json:"totp,omitempty"`
}

func (s *ConfigAuth) Insert(v *ConfigAuthInsertInput) {
	if v.Version != nil {
		s.Version = *v.Version
	}
	if v.Redirections != nil {
		if s.Redirections == nil {
			s.Redirections = &ConfigAuthRedirections{}
		}
		s.Redirections.Insert(v.Redirections)
	}
	if v.SignUp != nil {
		if s.SignUp == nil {
			s.SignUp = &ConfigAuthSignUp{}
		}
		s.SignUp.Insert(v.SignUp)
	}
	if v.User != nil {
		if s.User == nil {
			s.User = &ConfigAuthUser{}
		}
		s.User.Insert(v.User)
	}
	if v.Session != nil {
		if s.Session == nil {
			s.Session = &ConfigAuthSession{}
		}
		s.Session.Insert(v.Session)
	}
	if v.Method != nil {
		if s.Method == nil {
			s.Method = &ConfigAuthMethod{}
		}
		s.Method.Insert(v.Method)
	}
	if v.Totp != nil {
		if s.Totp == nil {
			s.Totp = &ConfigAuthTotp{}
		}
		s.Totp.Insert(v.Totp)
	}
}

func (s *ConfigAuth) Clone() *ConfigAuth {
	if s == nil {
		return nil
	}

	v := &ConfigAuth{}
	v.Version = s.Version
	v.Redirections = s.Redirections.Clone()
	v.SignUp = s.SignUp.Clone()
	v.User = s.User.Clone()
	v.Session = s.Session.Clone()
	v.Method = s.Method.Clone()
	v.Totp = s.Totp.Clone()
	return v
}

type ConfigAuthComparisonExp struct {
	And          []*ConfigAuthComparisonExp           `json:"_and,omitempty"`
	Not          *ConfigAuthComparisonExp             `json:"_not,omitempty"`
	Or           []*ConfigAuthComparisonExp           `json:"_or,omitempty"`
	Version      *ConfigStringComparisonExp           `json:"version,omitempty"`
	Redirections *ConfigAuthRedirectionsComparisonExp `json:"redirections,omitempty"`
	SignUp       *ConfigAuthSignUpComparisonExp       `json:"signUp,omitempty"`
	User         *ConfigAuthUserComparisonExp         `json:"user,omitempty"`
	Session      *ConfigAuthSessionComparisonExp      `json:"session,omitempty"`
	Method       *ConfigAuthMethodComparisonExp       `json:"method,omitempty"`
	Totp         *ConfigAuthTotpComparisonExp         `json:"totp,omitempty"`
}

func (exp *ConfigAuthComparisonExp) Matches(o *ConfigAuth) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuth{
			Redirections: &ConfigAuthRedirections{},
			SignUp:       &ConfigAuthSignUp{},
			User:         &ConfigAuthUser{},
			Session:      &ConfigAuthSession{},
			Method:       &ConfigAuthMethod{},
			Totp:         &ConfigAuthTotp{},
		}
	}
	if !exp.Version.Matches(o.Version) {
		return false
	}
	if !exp.Redirections.Matches(o.Redirections) {
		return false
	}
	if !exp.SignUp.Matches(o.SignUp) {
		return false
	}
	if !exp.User.Matches(o.User) {
		return false
	}
	if !exp.Session.Matches(o.Session) {
		return false
	}
	if !exp.Method.Matches(o.Method) {
		return false
	}
	if !exp.Totp.Matches(o.Totp) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethod struct {
	Anonymous         *ConfigAuthMethodAnonymous         `json:"anonymous,omitempty"`
	EmailPasswordless *ConfigAuthMethodEmailPasswordless `json:"emailPasswordless,omitempty"`
	EmailPassword     *ConfigAuthMethodEmailPassword     `json:"emailPassword,omitempty"`
	SmsPasswordless   *ConfigAuthMethodSmsPasswordless   `json:"smsPasswordless,omitempty"`
	Oauth             *ConfigAuthMethodOauth             `json:"oauth,omitempty"`
	Webauthn          *ConfigAuthMethodWebauthn          `json:"webauthn,omitempty"`
}

func (o *ConfigAuthMethod) GetAnonymous() *ConfigAuthMethodAnonymous {
	if o == nil {
		return nil
	}

	return o.Anonymous
}

func (o *ConfigAuthMethod) GetEmailPasswordless() *ConfigAuthMethodEmailPasswordless {
	if o == nil {
		return nil
	}

	return o.EmailPasswordless
}

func (o *ConfigAuthMethod) GetEmailPassword() *ConfigAuthMethodEmailPassword {
	if o == nil {
		return nil
	}

	return o.EmailPassword
}

func (o *ConfigAuthMethod) GetSmsPasswordless() *ConfigAuthMethodSmsPasswordless {
	if o == nil {
		return nil
	}

	return o.SmsPasswordless
}

func (o *ConfigAuthMethod) GetOauth() *ConfigAuthMethodOauth {
	if o == nil {
		return nil
	}

	return o.Oauth
}

func (o *ConfigAuthMethod) GetWebauthn() *ConfigAuthMethodWebauthn {
	if o == nil {
		return nil
	}

	return o.Webauthn
}

type ConfigAuthMethodUpdateInput struct {
	Anonymous         *ConfigAuthMethodAnonymousUpdateInput         `json:"anonymous,omitempty"`
	EmailPasswordless *ConfigAuthMethodEmailPasswordlessUpdateInput `json:"emailPasswordless,omitempty"`
	EmailPassword     *ConfigAuthMethodEmailPasswordUpdateInput     `json:"emailPassword,omitempty"`
	SmsPasswordless   *ConfigAuthMethodSmsPasswordlessUpdateInput   `json:"smsPasswordless,omitempty"`
	Oauth             *ConfigAuthMethodOauthUpdateInput             `json:"oauth,omitempty"`
	Webauthn          *ConfigAuthMethodWebauthnUpdateInput          `json:"webauthn,omitempty"`
}

func (s *ConfigAuthMethod) Update(v *ConfigAuthMethodUpdateInput) {
	if v == nil {
		return
	}
	if v.Anonymous != nil {
		if s.Anonymous == nil {
			s.Anonymous = &ConfigAuthMethodAnonymous{}
		}
		s.Anonymous.Update(v.Anonymous)
	}
	if v.EmailPasswordless != nil {
		if s.EmailPasswordless == nil {
			s.EmailPasswordless = &ConfigAuthMethodEmailPasswordless{}
		}
		s.EmailPasswordless.Update(v.EmailPasswordless)
	}
	if v.EmailPassword != nil {
		if s.EmailPassword == nil {
			s.EmailPassword = &ConfigAuthMethodEmailPassword{}
		}
		s.EmailPassword.Update(v.EmailPassword)
	}
	if v.SmsPasswordless != nil {
		if s.SmsPasswordless == nil {
			s.SmsPasswordless = &ConfigAuthMethodSmsPasswordless{}
		}
		s.SmsPasswordless.Update(v.SmsPasswordless)
	}
	if v.Oauth != nil {
		if s.Oauth == nil {
			s.Oauth = &ConfigAuthMethodOauth{}
		}
		s.Oauth.Update(v.Oauth)
	}
	if v.Webauthn != nil {
		if s.Webauthn == nil {
			s.Webauthn = &ConfigAuthMethodWebauthn{}
		}
		s.Webauthn.Update(v.Webauthn)
	}
}

type ConfigAuthMethodInsertInput struct {
	Anonymous         *ConfigAuthMethodAnonymousInsertInput         `json:"anonymous,omitempty"`
	EmailPasswordless *ConfigAuthMethodEmailPasswordlessInsertInput `json:"emailPasswordless,omitempty"`
	EmailPassword     *ConfigAuthMethodEmailPasswordInsertInput     `json:"emailPassword,omitempty"`
	SmsPasswordless   *ConfigAuthMethodSmsPasswordlessInsertInput   `json:"smsPasswordless,omitempty"`
	Oauth             *ConfigAuthMethodOauthInsertInput             `json:"oauth,omitempty"`
	Webauthn          *ConfigAuthMethodWebauthnInsertInput          `json:"webauthn,omitempty"`
}

func (s *ConfigAuthMethod) Insert(v *ConfigAuthMethodInsertInput) {
	if v.Anonymous != nil {
		if s.Anonymous == nil {
			s.Anonymous = &ConfigAuthMethodAnonymous{}
		}
		s.Anonymous.Insert(v.Anonymous)
	}
	if v.EmailPasswordless != nil {
		if s.EmailPasswordless == nil {
			s.EmailPasswordless = &ConfigAuthMethodEmailPasswordless{}
		}
		s.EmailPasswordless.Insert(v.EmailPasswordless)
	}
	if v.EmailPassword != nil {
		if s.EmailPassword == nil {
			s.EmailPassword = &ConfigAuthMethodEmailPassword{}
		}
		s.EmailPassword.Insert(v.EmailPassword)
	}
	if v.SmsPasswordless != nil {
		if s.SmsPasswordless == nil {
			s.SmsPasswordless = &ConfigAuthMethodSmsPasswordless{}
		}
		s.SmsPasswordless.Insert(v.SmsPasswordless)
	}
	if v.Oauth != nil {
		if s.Oauth == nil {
			s.Oauth = &ConfigAuthMethodOauth{}
		}
		s.Oauth.Insert(v.Oauth)
	}
	if v.Webauthn != nil {
		if s.Webauthn == nil {
			s.Webauthn = &ConfigAuthMethodWebauthn{}
		}
		s.Webauthn.Insert(v.Webauthn)
	}
}

func (s *ConfigAuthMethod) Clone() *ConfigAuthMethod {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethod{}
	v.Anonymous = s.Anonymous.Clone()
	v.EmailPasswordless = s.EmailPasswordless.Clone()
	v.EmailPassword = s.EmailPassword.Clone()
	v.SmsPasswordless = s.SmsPasswordless.Clone()
	v.Oauth = s.Oauth.Clone()
	v.Webauthn = s.Webauthn.Clone()
	return v
}

type ConfigAuthMethodComparisonExp struct {
	And               []*ConfigAuthMethodComparisonExp                `json:"_and,omitempty"`
	Not               *ConfigAuthMethodComparisonExp                  `json:"_not,omitempty"`
	Or                []*ConfigAuthMethodComparisonExp                `json:"_or,omitempty"`
	Anonymous         *ConfigAuthMethodAnonymousComparisonExp         `json:"anonymous,omitempty"`
	EmailPasswordless *ConfigAuthMethodEmailPasswordlessComparisonExp `json:"emailPasswordless,omitempty"`
	EmailPassword     *ConfigAuthMethodEmailPasswordComparisonExp     `json:"emailPassword,omitempty"`
	SmsPasswordless   *ConfigAuthMethodSmsPasswordlessComparisonExp   `json:"smsPasswordless,omitempty"`
	Oauth             *ConfigAuthMethodOauthComparisonExp             `json:"oauth,omitempty"`
	Webauthn          *ConfigAuthMethodWebauthnComparisonExp          `json:"webauthn,omitempty"`
}

func (exp *ConfigAuthMethodComparisonExp) Matches(o *ConfigAuthMethod) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethod{
			Anonymous:         &ConfigAuthMethodAnonymous{},
			EmailPasswordless: &ConfigAuthMethodEmailPasswordless{},
			EmailPassword:     &ConfigAuthMethodEmailPassword{},
			SmsPasswordless:   &ConfigAuthMethodSmsPasswordless{},
			Oauth:             &ConfigAuthMethodOauth{},
			Webauthn:          &ConfigAuthMethodWebauthn{},
		}
	}
	if !exp.Anonymous.Matches(o.Anonymous) {
		return false
	}
	if !exp.EmailPasswordless.Matches(o.EmailPasswordless) {
		return false
	}
	if !exp.EmailPassword.Matches(o.EmailPassword) {
		return false
	}
	if !exp.SmsPasswordless.Matches(o.SmsPasswordless) {
		return false
	}
	if !exp.Oauth.Matches(o.Oauth) {
		return false
	}
	if !exp.Webauthn.Matches(o.Webauthn) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodAnonymous struct {
	Enabled bool `json:"enabled,omitempty"`
}

func (o *ConfigAuthMethodAnonymous) GetEnabled() bool {
	if o == nil {
		o = &ConfigAuthMethodAnonymous{}
	}

	return o.Enabled
}

type ConfigAuthMethodAnonymousUpdateInput struct {
	Enabled *bool `json:"enabled,omitempty"`
}

func (s *ConfigAuthMethodAnonymous) Update(v *ConfigAuthMethodAnonymousUpdateInput) {
	if v == nil {
		return
	}
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
}

type ConfigAuthMethodAnonymousInsertInput struct {
	Enabled *bool `json:"enabled,omitempty"`
}

func (s *ConfigAuthMethodAnonymous) Insert(v *ConfigAuthMethodAnonymousInsertInput) {
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
}

func (s *ConfigAuthMethodAnonymous) Clone() *ConfigAuthMethodAnonymous {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodAnonymous{}
	v.Enabled = s.Enabled
	return v
}

type ConfigAuthMethodAnonymousComparisonExp struct {
	And     []*ConfigAuthMethodAnonymousComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthMethodAnonymousComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthMethodAnonymousComparisonExp `json:"_or,omitempty"`
	Enabled *ConfigBooleanComparisonExp               `json:"enabled,omitempty"`
}

func (exp *ConfigAuthMethodAnonymousComparisonExp) Matches(o *ConfigAuthMethodAnonymous) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodAnonymous{}
	}
	if !exp.Enabled.Matches(o.Enabled) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodEmailPassword struct {
	HibpEnabled               bool  `json:"hibpEnabled,omitempty"`
	EmailVerificationRequired bool  `json:"emailVerificationRequired,omitempty"`
	PasswordMinLength         uint8 `json:"passwordMinLength,omitempty"`
}

func (o *ConfigAuthMethodEmailPassword) GetHibpEnabled() bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPassword{}
	}

	return o.HibpEnabled
}

func (o *ConfigAuthMethodEmailPassword) GetEmailVerificationRequired() bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPassword{}
	}

	return o.EmailVerificationRequired
}

func (o *ConfigAuthMethodEmailPassword) GetPasswordMinLength() uint8 {
	if o == nil {
		o = &ConfigAuthMethodEmailPassword{}
	}

	return o.PasswordMinLength
}

type ConfigAuthMethodEmailPasswordUpdateInput struct {
	HibpEnabled               *bool  `json:"hibpEnabled,omitempty"`
	EmailVerificationRequired *bool  `json:"emailVerificationRequired,omitempty"`
	PasswordMinLength         *uint8 `json:"passwordMinLength,omitempty"`
}

func (s *ConfigAuthMethodEmailPassword) Update(v *ConfigAuthMethodEmailPasswordUpdateInput) {
	if v == nil {
		return
	}
	if v.HibpEnabled != nil {
		s.HibpEnabled = *v.HibpEnabled
	}
	if v.EmailVerificationRequired != nil {
		s.EmailVerificationRequired = *v.EmailVerificationRequired
	}
	if v.PasswordMinLength != nil {
		s.PasswordMinLength = *v.PasswordMinLength
	}
}

type ConfigAuthMethodEmailPasswordInsertInput struct {
	HibpEnabled               *bool  `json:"hibpEnabled,omitempty"`
	EmailVerificationRequired *bool  `json:"emailVerificationRequired,omitempty"`
	PasswordMinLength         *uint8 `json:"passwordMinLength,omitempty"`
}

func (s *ConfigAuthMethodEmailPassword) Insert(v *ConfigAuthMethodEmailPasswordInsertInput) {
	if v.HibpEnabled != nil {
		s.HibpEnabled = *v.HibpEnabled
	}
	if v.EmailVerificationRequired != nil {
		s.EmailVerificationRequired = *v.EmailVerificationRequired
	}
	if v.PasswordMinLength != nil {
		s.PasswordMinLength = *v.PasswordMinLength
	}
}

func (s *ConfigAuthMethodEmailPassword) Clone() *ConfigAuthMethodEmailPassword {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodEmailPassword{}
	v.HibpEnabled = s.HibpEnabled
	v.EmailVerificationRequired = s.EmailVerificationRequired
	v.PasswordMinLength = s.PasswordMinLength
	return v
}

type ConfigAuthMethodEmailPasswordComparisonExp struct {
	And                       []*ConfigAuthMethodEmailPasswordComparisonExp `json:"_and,omitempty"`
	Not                       *ConfigAuthMethodEmailPasswordComparisonExp   `json:"_not,omitempty"`
	Or                        []*ConfigAuthMethodEmailPasswordComparisonExp `json:"_or,omitempty"`
	HibpEnabled               *ConfigBooleanComparisonExp                   `json:"hibpEnabled,omitempty"`
	EmailVerificationRequired *ConfigBooleanComparisonExp                   `json:"emailVerificationRequired,omitempty"`
	PasswordMinLength         *ConfigUint8ComparisonExp                     `json:"passwordMinLength,omitempty"`
}

func (exp *ConfigAuthMethodEmailPasswordComparisonExp) Matches(o *ConfigAuthMethodEmailPassword) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodEmailPassword{}
	}
	if !exp.HibpEnabled.Matches(o.HibpEnabled) {
		return false
	}
	if !exp.EmailVerificationRequired.Matches(o.EmailVerificationRequired) {
		return false
	}
	if !exp.PasswordMinLength.Matches(o.PasswordMinLength) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodEmailPasswordless struct {
	Enabled bool `json:"enabled,omitempty"`
}

func (o *ConfigAuthMethodEmailPasswordless) GetEnabled() bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPasswordless{}
	}

	return o.Enabled
}

type ConfigAuthMethodEmailPasswordlessUpdateInput struct {
	Enabled *bool `json:"enabled,omitempty"`
}

func (s *ConfigAuthMethodEmailPasswordless) Update(v *ConfigAuthMethodEmailPasswordlessUpdateInput) {
	if v == nil {
		return
	}
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
}

type ConfigAuthMethodEmailPasswordlessInsertInput struct {
	Enabled *bool `json:"enabled,omitempty"`
}

func (s *ConfigAuthMethodEmailPasswordless) Insert(v *ConfigAuthMethodEmailPasswordlessInsertInput) {
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
}

func (s *ConfigAuthMethodEmailPasswordless) Clone() *ConfigAuthMethodEmailPasswordless {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodEmailPasswordless{}
	v.Enabled = s.Enabled
	return v
}

type ConfigAuthMethodEmailPasswordlessComparisonExp struct {
	And     []*ConfigAuthMethodEmailPasswordlessComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthMethodEmailPasswordlessComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthMethodEmailPasswordlessComparisonExp `json:"_or,omitempty"`
	Enabled *ConfigBooleanComparisonExp                       `json:"enabled,omitempty"`
}

func (exp *ConfigAuthMethodEmailPasswordlessComparisonExp) Matches(o *ConfigAuthMethodEmailPasswordless) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodEmailPasswordless{}
	}
	if !exp.Enabled.Matches(o.Enabled) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodOauth struct {
	Apple       *ConfigAuthMethodOauthApple   `json:"apple,omitempty"`
	Azuread     *ConfigAuthMethodOauthAzuread `json:"azuread,omitempty"`
	Bitbucket   *ConfigStandardOauthProvider  `json:"bitbucket,omitempty"`
	Discord     *ConfigStandardOauthProvider  `json:"discord,omitempty"`
	Facebook    *ConfigStandardOauthProvider  `json:"facebook,omitempty"`
	Github      *ConfigStandardOauthProvider  `json:"github,omitempty"`
	Gitlab      *ConfigStandardOauthProvider  `json:"gitlab,omitempty"`
	Google      *ConfigStandardOauthProvider  `json:"google,omitempty"`
	Linkedin    *ConfigStandardOauthProvider  `json:"linkedin,omitempty"`
	Spotify     *ConfigStandardOauthProvider  `json:"spotify,omitempty"`
	Strava      *ConfigStandardOauthProvider  `json:"strava,omitempty"`
	Twitch      *ConfigStandardOauthProvider  `json:"twitch,omitempty"`
	Twitter     *ConfigAuthMethodOauthTwitter `json:"twitter,omitempty"`
	Windowslive *ConfigStandardOauthProvider  `json:"windowslive,omitempty"`
	Workos      *ConfigAuthMethodOauthWorkos  `json:"workos,omitempty"`
}

func (o *ConfigAuthMethodOauth) GetApple() *ConfigAuthMethodOauthApple {
	if o == nil {
		return nil
	}

	return o.Apple
}

func (o *ConfigAuthMethodOauth) GetAzuread() *ConfigAuthMethodOauthAzuread {
	if o == nil {
		return nil
	}

	return o.Azuread
}

func (o *ConfigAuthMethodOauth) GetBitbucket() *ConfigStandardOauthProvider {
	if o == nil {
		return nil
	}

	return o.Bitbucket
}

func (o *ConfigAuthMethodOauth) GetDiscord() *ConfigStandardOauthProvider {
	if o == nil {
		return nil
	}

	return o.Discord
}

func (o *ConfigAuthMethodOauth) GetFacebook() *ConfigStandardOauthProvider {
	if o == nil {
		return nil
	}

	return o.Facebook
}

func (o *ConfigAuthMethodOauth) GetGithub() *ConfigStandardOauthProvider {
	if o == nil {
		return nil
	}

	return o.Github
}

func (o *ConfigAuthMethodOauth) GetGitlab() *ConfigStandardOauthProvider {
	if o == nil {
		return nil
	}

	return o.Gitlab
}

func (o *ConfigAuthMethodOauth) GetGoogle() *ConfigStandardOauthProvider {
	if o == nil {
		return nil
	}

	return o.Google
}

func (o *ConfigAuthMethodOauth) GetLinkedin() *ConfigStandardOauthProvider {
	if o == nil {
		return nil
	}

	return o.Linkedin
}

func (o *ConfigAuthMethodOauth) GetSpotify() *ConfigStandardOauthProvider {
	if o == nil {
		return nil
	}

	return o.Spotify
}

func (o *ConfigAuthMethodOauth) GetStrava() *ConfigStandardOauthProvider {
	if o == nil {
		return nil
	}

	return o.Strava
}

func (o *ConfigAuthMethodOauth) GetTwitch() *ConfigStandardOauthProvider {
	if o == nil {
		return nil
	}

	return o.Twitch
}

func (o *ConfigAuthMethodOauth) GetTwitter() *ConfigAuthMethodOauthTwitter {
	if o == nil {
		return nil
	}

	return o.Twitter
}

func (o *ConfigAuthMethodOauth) GetWindowslive() *ConfigStandardOauthProvider {
	if o == nil {
		return nil
	}

	return o.Windowslive
}

func (o *ConfigAuthMethodOauth) GetWorkos() *ConfigAuthMethodOauthWorkos {
	if o == nil {
		return nil
	}

	return o.Workos
}

type ConfigAuthMethodOauthUpdateInput struct {
	Apple       *ConfigAuthMethodOauthAppleUpdateInput   `json:"apple,omitempty"`
	Azuread     *ConfigAuthMethodOauthAzureadUpdateInput `json:"azuread,omitempty"`
	Bitbucket   *ConfigStandardOauthProviderUpdateInput  `json:"bitbucket,omitempty"`
	Discord     *ConfigStandardOauthProviderUpdateInput  `json:"discord,omitempty"`
	Facebook    *ConfigStandardOauthProviderUpdateInput  `json:"facebook,omitempty"`
	Github      *ConfigStandardOauthProviderUpdateInput  `json:"github,omitempty"`
	Gitlab      *ConfigStandardOauthProviderUpdateInput  `json:"gitlab,omitempty"`
	Google      *ConfigStandardOauthProviderUpdateInput  `json:"google,omitempty"`
	Linkedin    *ConfigStandardOauthProviderUpdateInput  `json:"linkedin,omitempty"`
	Spotify     *ConfigStandardOauthProviderUpdateInput  `json:"spotify,omitempty"`
	Strava      *ConfigStandardOauthProviderUpdateInput  `json:"strava,omitempty"`
	Twitch      *ConfigStandardOauthProviderUpdateInput  `json:"twitch,omitempty"`
	Twitter     *ConfigAuthMethodOauthTwitterUpdateInput `json:"twitter,omitempty"`
	Windowslive *ConfigStandardOauthProviderUpdateInput  `json:"windowslive,omitempty"`
	Workos      *ConfigAuthMethodOauthWorkosUpdateInput  `json:"workos,omitempty"`
}

func (s *ConfigAuthMethodOauth) Update(v *ConfigAuthMethodOauthUpdateInput) {
	if v == nil {
		return
	}
	if v.Apple != nil {
		if s.Apple == nil {
			s.Apple = &ConfigAuthMethodOauthApple{}
		}
		s.Apple.Update(v.Apple)
	}
	if v.Azuread != nil {
		if s.Azuread == nil {
			s.Azuread = &ConfigAuthMethodOauthAzuread{}
		}
		s.Azuread.Update(v.Azuread)
	}
	if v.Bitbucket != nil {
		if s.Bitbucket == nil {
			s.Bitbucket = &ConfigStandardOauthProvider{}
		}
		s.Bitbucket.Update(v.Bitbucket)
	}
	if v.Discord != nil {
		if s.Discord == nil {
			s.Discord = &ConfigStandardOauthProvider{}
		}
		s.Discord.Update(v.Discord)
	}
	if v.Facebook != nil {
		if s.Facebook == nil {
			s.Facebook = &ConfigStandardOauthProvider{}
		}
		s.Facebook.Update(v.Facebook)
	}
	if v.Github != nil {
		if s.Github == nil {
			s.Github = &ConfigStandardOauthProvider{}
		}
		s.Github.Update(v.Github)
	}
	if v.Gitlab != nil {
		if s.Gitlab == nil {
			s.Gitlab = &ConfigStandardOauthProvider{}
		}
		s.Gitlab.Update(v.Gitlab)
	}
	if v.Google != nil {
		if s.Google == nil {
			s.Google = &ConfigStandardOauthProvider{}
		}
		s.Google.Update(v.Google)
	}
	if v.Linkedin != nil {
		if s.Linkedin == nil {
			s.Linkedin = &ConfigStandardOauthProvider{}
		}
		s.Linkedin.Update(v.Linkedin)
	}
	if v.Spotify != nil {
		if s.Spotify == nil {
			s.Spotify = &ConfigStandardOauthProvider{}
		}
		s.Spotify.Update(v.Spotify)
	}
	if v.Strava != nil {
		if s.Strava == nil {
			s.Strava = &ConfigStandardOauthProvider{}
		}
		s.Strava.Update(v.Strava)
	}
	if v.Twitch != nil {
		if s.Twitch == nil {
			s.Twitch = &ConfigStandardOauthProvider{}
		}
		s.Twitch.Update(v.Twitch)
	}
	if v.Twitter != nil {
		if s.Twitter == nil {
			s.Twitter = &ConfigAuthMethodOauthTwitter{}
		}
		s.Twitter.Update(v.Twitter)
	}
	if v.Windowslive != nil {
		if s.Windowslive == nil {
			s.Windowslive = &ConfigStandardOauthProvider{}
		}
		s.Windowslive.Update(v.Windowslive)
	}
	if v.Workos != nil {
		if s.Workos == nil {
			s.Workos = &ConfigAuthMethodOauthWorkos{}
		}
		s.Workos.Update(v.Workos)
	}
}

type ConfigAuthMethodOauthInsertInput struct {
	Apple       *ConfigAuthMethodOauthAppleInsertInput   `json:"apple,omitempty"`
	Azuread     *ConfigAuthMethodOauthAzureadInsertInput `json:"azuread,omitempty"`
	Bitbucket   *ConfigStandardOauthProviderInsertInput  `json:"bitbucket,omitempty"`
	Discord     *ConfigStandardOauthProviderInsertInput  `json:"discord,omitempty"`
	Facebook    *ConfigStandardOauthProviderInsertInput  `json:"facebook,omitempty"`
	Github      *ConfigStandardOauthProviderInsertInput  `json:"github,omitempty"`
	Gitlab      *ConfigStandardOauthProviderInsertInput  `json:"gitlab,omitempty"`
	Google      *ConfigStandardOauthProviderInsertInput  `json:"google,omitempty"`
	Linkedin    *ConfigStandardOauthProviderInsertInput  `json:"linkedin,omitempty"`
	Spotify     *ConfigStandardOauthProviderInsertInput  `json:"spotify,omitempty"`
	Strava      *ConfigStandardOauthProviderInsertInput  `json:"strava,omitempty"`
	Twitch      *ConfigStandardOauthProviderInsertInput  `json:"twitch,omitempty"`
	Twitter     *ConfigAuthMethodOauthTwitterInsertInput `json:"twitter,omitempty"`
	Windowslive *ConfigStandardOauthProviderInsertInput  `json:"windowslive,omitempty"`
	Workos      *ConfigAuthMethodOauthWorkosInsertInput  `json:"workos,omitempty"`
}

func (s *ConfigAuthMethodOauth) Insert(v *ConfigAuthMethodOauthInsertInput) {
	if v.Apple != nil {
		if s.Apple == nil {
			s.Apple = &ConfigAuthMethodOauthApple{}
		}
		s.Apple.Insert(v.Apple)
	}
	if v.Azuread != nil {
		if s.Azuread == nil {
			s.Azuread = &ConfigAuthMethodOauthAzuread{}
		}
		s.Azuread.Insert(v.Azuread)
	}
	if v.Bitbucket != nil {
		if s.Bitbucket == nil {
			s.Bitbucket = &ConfigStandardOauthProvider{}
		}
		s.Bitbucket.Insert(v.Bitbucket)
	}
	if v.Discord != nil {
		if s.Discord == nil {
			s.Discord = &ConfigStandardOauthProvider{}
		}
		s.Discord.Insert(v.Discord)
	}
	if v.Facebook != nil {
		if s.Facebook == nil {
			s.Facebook = &ConfigStandardOauthProvider{}
		}
		s.Facebook.Insert(v.Facebook)
	}
	if v.Github != nil {
		if s.Github == nil {
			s.Github = &ConfigStandardOauthProvider{}
		}
		s.Github.Insert(v.Github)
	}
	if v.Gitlab != nil {
		if s.Gitlab == nil {
			s.Gitlab = &ConfigStandardOauthProvider{}
		}
		s.Gitlab.Insert(v.Gitlab)
	}
	if v.Google != nil {
		if s.Google == nil {
			s.Google = &ConfigStandardOauthProvider{}
		}
		s.Google.Insert(v.Google)
	}
	if v.Linkedin != nil {
		if s.Linkedin == nil {
			s.Linkedin = &ConfigStandardOauthProvider{}
		}
		s.Linkedin.Insert(v.Linkedin)
	}
	if v.Spotify != nil {
		if s.Spotify == nil {
			s.Spotify = &ConfigStandardOauthProvider{}
		}
		s.Spotify.Insert(v.Spotify)
	}
	if v.Strava != nil {
		if s.Strava == nil {
			s.Strava = &ConfigStandardOauthProvider{}
		}
		s.Strava.Insert(v.Strava)
	}
	if v.Twitch != nil {
		if s.Twitch == nil {
			s.Twitch = &ConfigStandardOauthProvider{}
		}
		s.Twitch.Insert(v.Twitch)
	}
	if v.Twitter != nil {
		if s.Twitter == nil {
			s.Twitter = &ConfigAuthMethodOauthTwitter{}
		}
		s.Twitter.Insert(v.Twitter)
	}
	if v.Windowslive != nil {
		if s.Windowslive == nil {
			s.Windowslive = &ConfigStandardOauthProvider{}
		}
		s.Windowslive.Insert(v.Windowslive)
	}
	if v.Workos != nil {
		if s.Workos == nil {
			s.Workos = &ConfigAuthMethodOauthWorkos{}
		}
		s.Workos.Insert(v.Workos)
	}
}

func (s *ConfigAuthMethodOauth) Clone() *ConfigAuthMethodOauth {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodOauth{}
	v.Apple = s.Apple.Clone()
	v.Azuread = s.Azuread.Clone()
	v.Bitbucket = s.Bitbucket.Clone()
	v.Discord = s.Discord.Clone()
	v.Facebook = s.Facebook.Clone()
	v.Github = s.Github.Clone()
	v.Gitlab = s.Gitlab.Clone()
	v.Google = s.Google.Clone()
	v.Linkedin = s.Linkedin.Clone()
	v.Spotify = s.Spotify.Clone()
	v.Strava = s.Strava.Clone()
	v.Twitch = s.Twitch.Clone()
	v.Twitter = s.Twitter.Clone()
	v.Windowslive = s.Windowslive.Clone()
	v.Workos = s.Workos.Clone()
	return v
}

type ConfigAuthMethodOauthComparisonExp struct {
	And         []*ConfigAuthMethodOauthComparisonExp      `json:"_and,omitempty"`
	Not         *ConfigAuthMethodOauthComparisonExp        `json:"_not,omitempty"`
	Or          []*ConfigAuthMethodOauthComparisonExp      `json:"_or,omitempty"`
	Apple       *ConfigAuthMethodOauthAppleComparisonExp   `json:"apple,omitempty"`
	Azuread     *ConfigAuthMethodOauthAzureadComparisonExp `json:"azuread,omitempty"`
	Bitbucket   *ConfigStandardOauthProviderComparisonExp  `json:"bitbucket,omitempty"`
	Discord     *ConfigStandardOauthProviderComparisonExp  `json:"discord,omitempty"`
	Facebook    *ConfigStandardOauthProviderComparisonExp  `json:"facebook,omitempty"`
	Github      *ConfigStandardOauthProviderComparisonExp  `json:"github,omitempty"`
	Gitlab      *ConfigStandardOauthProviderComparisonExp  `json:"gitlab,omitempty"`
	Google      *ConfigStandardOauthProviderComparisonExp  `json:"google,omitempty"`
	Linkedin    *ConfigStandardOauthProviderComparisonExp  `json:"linkedin,omitempty"`
	Spotify     *ConfigStandardOauthProviderComparisonExp  `json:"spotify,omitempty"`
	Strava      *ConfigStandardOauthProviderComparisonExp  `json:"strava,omitempty"`
	Twitch      *ConfigStandardOauthProviderComparisonExp  `json:"twitch,omitempty"`
	Twitter     *ConfigAuthMethodOauthTwitterComparisonExp `json:"twitter,omitempty"`
	Windowslive *ConfigStandardOauthProviderComparisonExp  `json:"windowslive,omitempty"`
	Workos      *ConfigAuthMethodOauthWorkosComparisonExp  `json:"workos,omitempty"`
}

func (exp *ConfigAuthMethodOauthComparisonExp) Matches(o *ConfigAuthMethodOauth) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodOauth{
			Apple:       &ConfigAuthMethodOauthApple{},
			Azuread:     &ConfigAuthMethodOauthAzuread{},
			Bitbucket:   &ConfigStandardOauthProvider{},
			Discord:     &ConfigStandardOauthProvider{},
			Facebook:    &ConfigStandardOauthProvider{},
			Github:      &ConfigStandardOauthProvider{},
			Gitlab:      &ConfigStandardOauthProvider{},
			Google:      &ConfigStandardOauthProvider{},
			Linkedin:    &ConfigStandardOauthProvider{},
			Spotify:     &ConfigStandardOauthProvider{},
			Strava:      &ConfigStandardOauthProvider{},
			Twitch:      &ConfigStandardOauthProvider{},
			Twitter:     &ConfigAuthMethodOauthTwitter{},
			Windowslive: &ConfigStandardOauthProvider{},
			Workos:      &ConfigAuthMethodOauthWorkos{},
		}
	}
	if !exp.Apple.Matches(o.Apple) {
		return false
	}
	if !exp.Azuread.Matches(o.Azuread) {
		return false
	}
	if !exp.Bitbucket.Matches(o.Bitbucket) {
		return false
	}
	if !exp.Discord.Matches(o.Discord) {
		return false
	}
	if !exp.Facebook.Matches(o.Facebook) {
		return false
	}
	if !exp.Github.Matches(o.Github) {
		return false
	}
	if !exp.Gitlab.Matches(o.Gitlab) {
		return false
	}
	if !exp.Google.Matches(o.Google) {
		return false
	}
	if !exp.Linkedin.Matches(o.Linkedin) {
		return false
	}
	if !exp.Spotify.Matches(o.Spotify) {
		return false
	}
	if !exp.Strava.Matches(o.Strava) {
		return false
	}
	if !exp.Twitch.Matches(o.Twitch) {
		return false
	}
	if !exp.Twitter.Matches(o.Twitter) {
		return false
	}
	if !exp.Windowslive.Matches(o.Windowslive) {
		return false
	}
	if !exp.Workos.Matches(o.Workos) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodOauthApple struct {
	Enabled    bool   `json:"enabled,omitempty"`
	ClientId   string `json:"clientId,omitempty"`
	KeyId      string `json:"keyId,omitempty"`
	TeamId     string `json:"teamId,omitempty"`
	PrivateKey string `json:"privateKey,omitempty"`
}

func (o *ConfigAuthMethodOauthApple) GetEnabled() bool {
	if o == nil {
		o = &ConfigAuthMethodOauthApple{}
	}

	return o.Enabled
}

func (o *ConfigAuthMethodOauthApple) GetClientId() string {
	if o == nil {
		o = &ConfigAuthMethodOauthApple{}
	}

	return o.ClientId
}

func (o *ConfigAuthMethodOauthApple) GetKeyId() string {
	if o == nil {
		o = &ConfigAuthMethodOauthApple{}
	}

	return o.KeyId
}

func (o *ConfigAuthMethodOauthApple) GetTeamId() string {
	if o == nil {
		o = &ConfigAuthMethodOauthApple{}
	}

	return o.TeamId
}

func (o *ConfigAuthMethodOauthApple) GetPrivateKey() string {
	if o == nil {
		o = &ConfigAuthMethodOauthApple{}
	}

	return o.PrivateKey
}

type ConfigAuthMethodOauthAppleUpdateInput struct {
	Enabled    *bool   `json:"enabled,omitempty"`
	ClientId   *string `json:"clientId,omitempty"`
	KeyId      *string `json:"keyId,omitempty"`
	TeamId     *string `json:"teamId,omitempty"`
	PrivateKey *string `json:"privateKey,omitempty"`
}

func (s *ConfigAuthMethodOauthApple) Update(v *ConfigAuthMethodOauthAppleUpdateInput) {
	if v == nil {
		return
	}
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
	if v.ClientId != nil {
		s.ClientId = *v.ClientId
	}
	if v.KeyId != nil {
		s.KeyId = *v.KeyId
	}
	if v.TeamId != nil {
		s.TeamId = *v.TeamId
	}
	if v.PrivateKey != nil {
		s.PrivateKey = *v.PrivateKey
	}
}

type ConfigAuthMethodOauthAppleInsertInput struct {
	Enabled    *bool   `json:"enabled,omitempty"`
	ClientId   *string `json:"clientId,omitempty"`
	KeyId      *string `json:"keyId,omitempty"`
	TeamId     *string `json:"teamId,omitempty"`
	PrivateKey *string `json:"privateKey,omitempty"`
}

func (s *ConfigAuthMethodOauthApple) Insert(v *ConfigAuthMethodOauthAppleInsertInput) {
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
	if v.ClientId != nil {
		s.ClientId = *v.ClientId
	}
	if v.KeyId != nil {
		s.KeyId = *v.KeyId
	}
	if v.TeamId != nil {
		s.TeamId = *v.TeamId
	}
	if v.PrivateKey != nil {
		s.PrivateKey = *v.PrivateKey
	}
}

func (s *ConfigAuthMethodOauthApple) Clone() *ConfigAuthMethodOauthApple {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodOauthApple{}
	v.Enabled = s.Enabled
	v.ClientId = s.ClientId
	v.KeyId = s.KeyId
	v.TeamId = s.TeamId
	v.PrivateKey = s.PrivateKey
	return v
}

type ConfigAuthMethodOauthAppleComparisonExp struct {
	And        []*ConfigAuthMethodOauthAppleComparisonExp `json:"_and,omitempty"`
	Not        *ConfigAuthMethodOauthAppleComparisonExp   `json:"_not,omitempty"`
	Or         []*ConfigAuthMethodOauthAppleComparisonExp `json:"_or,omitempty"`
	Enabled    *ConfigBooleanComparisonExp                `json:"enabled,omitempty"`
	ClientId   *ConfigStringComparisonExp                 `json:"clientId,omitempty"`
	KeyId      *ConfigStringComparisonExp                 `json:"keyId,omitempty"`
	TeamId     *ConfigStringComparisonExp                 `json:"teamId,omitempty"`
	PrivateKey *ConfigStringComparisonExp                 `json:"privateKey,omitempty"`
}

func (exp *ConfigAuthMethodOauthAppleComparisonExp) Matches(o *ConfigAuthMethodOauthApple) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodOauthApple{}
	}
	if !exp.Enabled.Matches(o.Enabled) {
		return false
	}
	if !exp.ClientId.Matches(o.ClientId) {
		return false
	}
	if !exp.KeyId.Matches(o.KeyId) {
		return false
	}
	if !exp.TeamId.Matches(o.TeamId) {
		return false
	}
	if !exp.PrivateKey.Matches(o.PrivateKey) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodOauthAzuread struct {
	Tenant       string   `json:"tenant,omitempty"`
	Enabled      bool     `json:"enabled,omitempty"`
	ClientId     string   `json:"clientId,omitempty"`
	Scope        []string `json:"scope,omitempty"`
	ClientSecret string   `json:"clientSecret,omitempty"`
}

func (o *ConfigAuthMethodOauthAzuread) GetTenant() string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzuread{}
	}

	return o.Tenant
}

func (o *ConfigAuthMethodOauthAzuread) GetEnabled() bool {
	if o == nil {
		o = &ConfigAuthMethodOauthAzuread{}
	}

	return o.Enabled
}

func (o *ConfigAuthMethodOauthAzuread) GetClientId() string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzuread{}
	}

	return o.ClientId
}

func (o *ConfigAuthMethodOauthAzuread) GetScope() []string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzuread{}
	}

	return o.Scope
}

func (o *ConfigAuthMethodOauthAzuread) GetClientSecret() string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzuread{}
	}

	return o.ClientSecret
}

type ConfigAuthMethodOauthAzureadUpdateInput struct {
	Tenant       *string  `json:"tenant,omitempty"`
	Enabled      *bool    `json:"enabled,omitempty"`
	ClientId     *string  `json:"clientId,omitempty"`
	Scope        []string `json:"scope,omitempty"`
	ClientSecret *string  `json:"clientSecret,omitempty"`
}

func (s *ConfigAuthMethodOauthAzuread) Update(v *ConfigAuthMethodOauthAzureadUpdateInput) {
	if v == nil {
		return
	}
	if v.Tenant != nil {
		s.Tenant = *v.Tenant
	}
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
	if v.ClientId != nil {
		s.ClientId = *v.ClientId
	}
	if v.Scope != nil {
		s.Scope = make([]string, len(v.Scope))
		for i, e := range v.Scope {
			s.Scope[i] = e
		}
	}
	if v.ClientSecret != nil {
		s.ClientSecret = *v.ClientSecret
	}
}

type ConfigAuthMethodOauthAzureadInsertInput struct {
	Tenant       *string  `json:"tenant,omitempty"`
	Enabled      *bool    `json:"enabled,omitempty"`
	ClientId     *string  `json:"clientId,omitempty"`
	Scope        []string `json:"scope,omitempty"`
	ClientSecret *string  `json:"clientSecret,omitempty"`
}

func (s *ConfigAuthMethodOauthAzuread) Insert(v *ConfigAuthMethodOauthAzureadInsertInput) {
	if v.Tenant != nil {
		s.Tenant = *v.Tenant
	}
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
	if v.ClientId != nil {
		s.ClientId = *v.ClientId
	}
	if v.Scope != nil {
		s.Scope = make([]string, len(v.Scope))
		for i, e := range v.Scope {
			s.Scope[i] = e
		}
	}
	if v.ClientSecret != nil {
		s.ClientSecret = *v.ClientSecret
	}
}

func (s *ConfigAuthMethodOauthAzuread) Clone() *ConfigAuthMethodOauthAzuread {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodOauthAzuread{}
	v.Tenant = s.Tenant
	v.Enabled = s.Enabled
	v.ClientId = s.ClientId
	v.Scope = make([]string, len(s.Scope))
	copy(v.Scope, s.Scope)
	v.ClientSecret = s.ClientSecret
	return v
}

type ConfigAuthMethodOauthAzureadComparisonExp struct {
	And          []*ConfigAuthMethodOauthAzureadComparisonExp `json:"_and,omitempty"`
	Not          *ConfigAuthMethodOauthAzureadComparisonExp   `json:"_not,omitempty"`
	Or           []*ConfigAuthMethodOauthAzureadComparisonExp `json:"_or,omitempty"`
	Tenant       *ConfigStringComparisonExp                   `json:"tenant,omitempty"`
	Enabled      *ConfigBooleanComparisonExp                  `json:"enabled,omitempty"`
	ClientId     *ConfigStringComparisonExp                   `json:"clientId,omitempty"`
	Scope        *ConfigStringComparisonExp                   `json:"scope,omitempty"`
	ClientSecret *ConfigStringComparisonExp                   `json:"clientSecret,omitempty"`
}

func (exp *ConfigAuthMethodOauthAzureadComparisonExp) Matches(o *ConfigAuthMethodOauthAzuread) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodOauthAzuread{
			Scope: []string{},
		}
	}
	if !exp.Tenant.Matches(o.Tenant) {
		return false
	}
	if !exp.Enabled.Matches(o.Enabled) {
		return false
	}
	if !exp.ClientId.Matches(o.ClientId) {
		return false
	}
	{
		found := false
		for _, o := range o.Scope {
			if exp.Scope.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Scope != nil {
			return false
		}
	}
	if !exp.ClientSecret.Matches(o.ClientSecret) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodOauthTwitter struct {
	Enabled        bool   `json:"enabled,omitempty"`
	ConsumerKey    string `json:"consumerKey,omitempty"`
	ConsumerSecret string `json:"consumerSecret,omitempty"`
}

func (o *ConfigAuthMethodOauthTwitter) GetEnabled() bool {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitter{}
	}

	return o.Enabled
}

func (o *ConfigAuthMethodOauthTwitter) GetConsumerKey() string {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitter{}
	}

	return o.ConsumerKey
}

func (o *ConfigAuthMethodOauthTwitter) GetConsumerSecret() string {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitter{}
	}

	return o.ConsumerSecret
}

type ConfigAuthMethodOauthTwitterUpdateInput struct {
	Enabled        *bool   `json:"enabled,omitempty"`
	ConsumerKey    *string `json:"consumerKey,omitempty"`
	ConsumerSecret *string `json:"consumerSecret,omitempty"`
}

func (s *ConfigAuthMethodOauthTwitter) Update(v *ConfigAuthMethodOauthTwitterUpdateInput) {
	if v == nil {
		return
	}
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
	if v.ConsumerKey != nil {
		s.ConsumerKey = *v.ConsumerKey
	}
	if v.ConsumerSecret != nil {
		s.ConsumerSecret = *v.ConsumerSecret
	}
}

type ConfigAuthMethodOauthTwitterInsertInput struct {
	Enabled        *bool   `json:"enabled,omitempty"`
	ConsumerKey    *string `json:"consumerKey,omitempty"`
	ConsumerSecret *string `json:"consumerSecret,omitempty"`
}

func (s *ConfigAuthMethodOauthTwitter) Insert(v *ConfigAuthMethodOauthTwitterInsertInput) {
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
	if v.ConsumerKey != nil {
		s.ConsumerKey = *v.ConsumerKey
	}
	if v.ConsumerSecret != nil {
		s.ConsumerSecret = *v.ConsumerSecret
	}
}

func (s *ConfigAuthMethodOauthTwitter) Clone() *ConfigAuthMethodOauthTwitter {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodOauthTwitter{}
	v.Enabled = s.Enabled
	v.ConsumerKey = s.ConsumerKey
	v.ConsumerSecret = s.ConsumerSecret
	return v
}

type ConfigAuthMethodOauthTwitterComparisonExp struct {
	And            []*ConfigAuthMethodOauthTwitterComparisonExp `json:"_and,omitempty"`
	Not            *ConfigAuthMethodOauthTwitterComparisonExp   `json:"_not,omitempty"`
	Or             []*ConfigAuthMethodOauthTwitterComparisonExp `json:"_or,omitempty"`
	Enabled        *ConfigBooleanComparisonExp                  `json:"enabled,omitempty"`
	ConsumerKey    *ConfigStringComparisonExp                   `json:"consumerKey,omitempty"`
	ConsumerSecret *ConfigStringComparisonExp                   `json:"consumerSecret,omitempty"`
}

func (exp *ConfigAuthMethodOauthTwitterComparisonExp) Matches(o *ConfigAuthMethodOauthTwitter) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodOauthTwitter{}
	}
	if !exp.Enabled.Matches(o.Enabled) {
		return false
	}
	if !exp.ConsumerKey.Matches(o.ConsumerKey) {
		return false
	}
	if !exp.ConsumerSecret.Matches(o.ConsumerSecret) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodOauthWorkos struct {
	Connection   string   `json:"connection,omitempty"`
	Enabled      bool     `json:"enabled,omitempty"`
	ClientId     string   `json:"clientId,omitempty"`
	Organization string   `json:"organization,omitempty"`
	Scope        []string `json:"scope,omitempty"`
	ClientSecret string   `json:"clientSecret,omitempty"`
}

func (o *ConfigAuthMethodOauthWorkos) GetConnection() string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkos{}
	}

	return o.Connection
}

func (o *ConfigAuthMethodOauthWorkos) GetEnabled() bool {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkos{}
	}

	return o.Enabled
}

func (o *ConfigAuthMethodOauthWorkos) GetClientId() string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkos{}
	}

	return o.ClientId
}

func (o *ConfigAuthMethodOauthWorkos) GetOrganization() string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkos{}
	}

	return o.Organization
}

func (o *ConfigAuthMethodOauthWorkos) GetScope() []string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkos{}
	}

	return o.Scope
}

func (o *ConfigAuthMethodOauthWorkos) GetClientSecret() string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkos{}
	}

	return o.ClientSecret
}

type ConfigAuthMethodOauthWorkosUpdateInput struct {
	Connection   *string  `json:"connection,omitempty"`
	Enabled      *bool    `json:"enabled,omitempty"`
	ClientId     *string  `json:"clientId,omitempty"`
	Organization *string  `json:"organization,omitempty"`
	Scope        []string `json:"scope,omitempty"`
	ClientSecret *string  `json:"clientSecret,omitempty"`
}

func (s *ConfigAuthMethodOauthWorkos) Update(v *ConfigAuthMethodOauthWorkosUpdateInput) {
	if v == nil {
		return
	}
	if v.Connection != nil {
		s.Connection = *v.Connection
	}
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
	if v.ClientId != nil {
		s.ClientId = *v.ClientId
	}
	if v.Organization != nil {
		s.Organization = *v.Organization
	}
	if v.Scope != nil {
		s.Scope = make([]string, len(v.Scope))
		for i, e := range v.Scope {
			s.Scope[i] = e
		}
	}
	if v.ClientSecret != nil {
		s.ClientSecret = *v.ClientSecret
	}
}

type ConfigAuthMethodOauthWorkosInsertInput struct {
	Connection   *string  `json:"connection,omitempty"`
	Enabled      *bool    `json:"enabled,omitempty"`
	ClientId     *string  `json:"clientId,omitempty"`
	Organization *string  `json:"organization,omitempty"`
	Scope        []string `json:"scope,omitempty"`
	ClientSecret *string  `json:"clientSecret,omitempty"`
}

func (s *ConfigAuthMethodOauthWorkos) Insert(v *ConfigAuthMethodOauthWorkosInsertInput) {
	if v.Connection != nil {
		s.Connection = *v.Connection
	}
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
	if v.ClientId != nil {
		s.ClientId = *v.ClientId
	}
	if v.Organization != nil {
		s.Organization = *v.Organization
	}
	if v.Scope != nil {
		s.Scope = make([]string, len(v.Scope))
		for i, e := range v.Scope {
			s.Scope[i] = e
		}
	}
	if v.ClientSecret != nil {
		s.ClientSecret = *v.ClientSecret
	}
}

func (s *ConfigAuthMethodOauthWorkos) Clone() *ConfigAuthMethodOauthWorkos {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodOauthWorkos{}
	v.Connection = s.Connection
	v.Enabled = s.Enabled
	v.ClientId = s.ClientId
	v.Organization = s.Organization
	v.Scope = make([]string, len(s.Scope))
	copy(v.Scope, s.Scope)
	v.ClientSecret = s.ClientSecret
	return v
}

type ConfigAuthMethodOauthWorkosComparisonExp struct {
	And          []*ConfigAuthMethodOauthWorkosComparisonExp `json:"_and,omitempty"`
	Not          *ConfigAuthMethodOauthWorkosComparisonExp   `json:"_not,omitempty"`
	Or           []*ConfigAuthMethodOauthWorkosComparisonExp `json:"_or,omitempty"`
	Connection   *ConfigStringComparisonExp                  `json:"connection,omitempty"`
	Enabled      *ConfigBooleanComparisonExp                 `json:"enabled,omitempty"`
	ClientId     *ConfigStringComparisonExp                  `json:"clientId,omitempty"`
	Organization *ConfigStringComparisonExp                  `json:"organization,omitempty"`
	Scope        *ConfigStringComparisonExp                  `json:"scope,omitempty"`
	ClientSecret *ConfigStringComparisonExp                  `json:"clientSecret,omitempty"`
}

func (exp *ConfigAuthMethodOauthWorkosComparisonExp) Matches(o *ConfigAuthMethodOauthWorkos) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodOauthWorkos{
			Scope: []string{},
		}
	}
	if !exp.Connection.Matches(o.Connection) {
		return false
	}
	if !exp.Enabled.Matches(o.Enabled) {
		return false
	}
	if !exp.ClientId.Matches(o.ClientId) {
		return false
	}
	if !exp.Organization.Matches(o.Organization) {
		return false
	}
	{
		found := false
		for _, o := range o.Scope {
			if exp.Scope.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Scope != nil {
			return false
		}
	}
	if !exp.ClientSecret.Matches(o.ClientSecret) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodSmsPasswordless struct {
	Enabled bool `json:"enabled,omitempty"`
}

func (o *ConfigAuthMethodSmsPasswordless) GetEnabled() bool {
	if o == nil {
		o = &ConfigAuthMethodSmsPasswordless{}
	}

	return o.Enabled
}

type ConfigAuthMethodSmsPasswordlessUpdateInput struct {
	Enabled *bool `json:"enabled,omitempty"`
}

func (s *ConfigAuthMethodSmsPasswordless) Update(v *ConfigAuthMethodSmsPasswordlessUpdateInput) {
	if v == nil {
		return
	}
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
}

type ConfigAuthMethodSmsPasswordlessInsertInput struct {
	Enabled *bool `json:"enabled,omitempty"`
}

func (s *ConfigAuthMethodSmsPasswordless) Insert(v *ConfigAuthMethodSmsPasswordlessInsertInput) {
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
}

func (s *ConfigAuthMethodSmsPasswordless) Clone() *ConfigAuthMethodSmsPasswordless {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodSmsPasswordless{}
	v.Enabled = s.Enabled
	return v
}

type ConfigAuthMethodSmsPasswordlessComparisonExp struct {
	And     []*ConfigAuthMethodSmsPasswordlessComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthMethodSmsPasswordlessComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthMethodSmsPasswordlessComparisonExp `json:"_or,omitempty"`
	Enabled *ConfigBooleanComparisonExp                     `json:"enabled,omitempty"`
}

func (exp *ConfigAuthMethodSmsPasswordlessComparisonExp) Matches(o *ConfigAuthMethodSmsPasswordless) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodSmsPasswordless{}
	}
	if !exp.Enabled.Matches(o.Enabled) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodWebauthn struct {
	Enabled      bool                                  `json:"enabled,omitempty"`
	RelyingParty *ConfigAuthMethodWebauthnRelyingParty `json:"relyingParty,omitempty"`
	Attestation  *ConfigAuthMethodWebauthnAttestation  `json:"attestation,omitempty"`
}

func (o *ConfigAuthMethodWebauthn) GetEnabled() bool {
	if o == nil {
		o = &ConfigAuthMethodWebauthn{}
	}

	return o.Enabled
}

func (o *ConfigAuthMethodWebauthn) GetRelyingParty() *ConfigAuthMethodWebauthnRelyingParty {
	if o == nil {
		return nil
	}

	return o.RelyingParty
}

func (o *ConfigAuthMethodWebauthn) GetAttestation() *ConfigAuthMethodWebauthnAttestation {
	if o == nil {
		return nil
	}

	return o.Attestation
}

type ConfigAuthMethodWebauthnUpdateInput struct {
	Enabled      *bool                                            `json:"enabled,omitempty"`
	RelyingParty *ConfigAuthMethodWebauthnRelyingPartyUpdateInput `json:"relyingParty,omitempty"`
	Attestation  *ConfigAuthMethodWebauthnAttestationUpdateInput  `json:"attestation,omitempty"`
}

func (s *ConfigAuthMethodWebauthn) Update(v *ConfigAuthMethodWebauthnUpdateInput) {
	if v == nil {
		return
	}
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
	if v.RelyingParty != nil {
		if s.RelyingParty == nil {
			s.RelyingParty = &ConfigAuthMethodWebauthnRelyingParty{}
		}
		s.RelyingParty.Update(v.RelyingParty)
	}
	if v.Attestation != nil {
		if s.Attestation == nil {
			s.Attestation = &ConfigAuthMethodWebauthnAttestation{}
		}
		s.Attestation.Update(v.Attestation)
	}
}

type ConfigAuthMethodWebauthnInsertInput struct {
	Enabled      *bool                                            `json:"enabled,omitempty"`
	RelyingParty *ConfigAuthMethodWebauthnRelyingPartyInsertInput `json:"relyingParty,omitempty"`
	Attestation  *ConfigAuthMethodWebauthnAttestationInsertInput  `json:"attestation,omitempty"`
}

func (s *ConfigAuthMethodWebauthn) Insert(v *ConfigAuthMethodWebauthnInsertInput) {
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
	if v.RelyingParty != nil {
		if s.RelyingParty == nil {
			s.RelyingParty = &ConfigAuthMethodWebauthnRelyingParty{}
		}
		s.RelyingParty.Insert(v.RelyingParty)
	}
	if v.Attestation != nil {
		if s.Attestation == nil {
			s.Attestation = &ConfigAuthMethodWebauthnAttestation{}
		}
		s.Attestation.Insert(v.Attestation)
	}
}

func (s *ConfigAuthMethodWebauthn) Clone() *ConfigAuthMethodWebauthn {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodWebauthn{}
	v.Enabled = s.Enabled
	v.RelyingParty = s.RelyingParty.Clone()
	v.Attestation = s.Attestation.Clone()
	return v
}

type ConfigAuthMethodWebauthnComparisonExp struct {
	And          []*ConfigAuthMethodWebauthnComparisonExp           `json:"_and,omitempty"`
	Not          *ConfigAuthMethodWebauthnComparisonExp             `json:"_not,omitempty"`
	Or           []*ConfigAuthMethodWebauthnComparisonExp           `json:"_or,omitempty"`
	Enabled      *ConfigBooleanComparisonExp                        `json:"enabled,omitempty"`
	RelyingParty *ConfigAuthMethodWebauthnRelyingPartyComparisonExp `json:"relyingParty,omitempty"`
	Attestation  *ConfigAuthMethodWebauthnAttestationComparisonExp  `json:"attestation,omitempty"`
}

func (exp *ConfigAuthMethodWebauthnComparisonExp) Matches(o *ConfigAuthMethodWebauthn) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodWebauthn{
			RelyingParty: &ConfigAuthMethodWebauthnRelyingParty{},
			Attestation:  &ConfigAuthMethodWebauthnAttestation{},
		}
	}
	if !exp.Enabled.Matches(o.Enabled) {
		return false
	}
	if !exp.RelyingParty.Matches(o.RelyingParty) {
		return false
	}
	if !exp.Attestation.Matches(o.Attestation) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodWebauthnAttestation struct {
	Timeout uint32 `json:"timeout,omitempty"`
}

func (o *ConfigAuthMethodWebauthnAttestation) GetTimeout() uint32 {
	if o == nil {
		o = &ConfigAuthMethodWebauthnAttestation{}
	}

	return o.Timeout
}

type ConfigAuthMethodWebauthnAttestationUpdateInput struct {
	Timeout *uint32 `json:"timeout,omitempty"`
}

func (s *ConfigAuthMethodWebauthnAttestation) Update(v *ConfigAuthMethodWebauthnAttestationUpdateInput) {
	if v == nil {
		return
	}
	if v.Timeout != nil {
		s.Timeout = *v.Timeout
	}
}

type ConfigAuthMethodWebauthnAttestationInsertInput struct {
	Timeout *uint32 `json:"timeout,omitempty"`
}

func (s *ConfigAuthMethodWebauthnAttestation) Insert(v *ConfigAuthMethodWebauthnAttestationInsertInput) {
	if v.Timeout != nil {
		s.Timeout = *v.Timeout
	}
}

func (s *ConfigAuthMethodWebauthnAttestation) Clone() *ConfigAuthMethodWebauthnAttestation {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodWebauthnAttestation{}
	v.Timeout = s.Timeout
	return v
}

type ConfigAuthMethodWebauthnAttestationComparisonExp struct {
	And     []*ConfigAuthMethodWebauthnAttestationComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthMethodWebauthnAttestationComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthMethodWebauthnAttestationComparisonExp `json:"_or,omitempty"`
	Timeout *ConfigUint32ComparisonExp                          `json:"timeout,omitempty"`
}

func (exp *ConfigAuthMethodWebauthnAttestationComparisonExp) Matches(o *ConfigAuthMethodWebauthnAttestation) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodWebauthnAttestation{}
	}
	if !exp.Timeout.Matches(o.Timeout) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodWebauthnRelyingParty struct {
	Name    string   `json:"name,omitempty"`
	Origins []string `json:"origins,omitempty"`
}

func (o *ConfigAuthMethodWebauthnRelyingParty) GetName() string {
	if o == nil {
		o = &ConfigAuthMethodWebauthnRelyingParty{}
	}

	return o.Name
}

func (o *ConfigAuthMethodWebauthnRelyingParty) GetOrigins() []string {
	if o == nil {
		o = &ConfigAuthMethodWebauthnRelyingParty{}
	}

	return o.Origins
}

type ConfigAuthMethodWebauthnRelyingPartyUpdateInput struct {
	Name    *string  `json:"name,omitempty"`
	Origins []string `json:"origins,omitempty"`
}

func (s *ConfigAuthMethodWebauthnRelyingParty) Update(v *ConfigAuthMethodWebauthnRelyingPartyUpdateInput) {
	if v == nil {
		return
	}
	if v.Name != nil {
		s.Name = *v.Name
	}
	if v.Origins != nil {
		s.Origins = make([]string, len(v.Origins))
		for i, e := range v.Origins {
			s.Origins[i] = e
		}
	}
}

type ConfigAuthMethodWebauthnRelyingPartyInsertInput struct {
	Name    *string  `json:"name,omitempty"`
	Origins []string `json:"origins,omitempty"`
}

func (s *ConfigAuthMethodWebauthnRelyingParty) Insert(v *ConfigAuthMethodWebauthnRelyingPartyInsertInput) {
	if v.Name != nil {
		s.Name = *v.Name
	}
	if v.Origins != nil {
		s.Origins = make([]string, len(v.Origins))
		for i, e := range v.Origins {
			s.Origins[i] = e
		}
	}
}

func (s *ConfigAuthMethodWebauthnRelyingParty) Clone() *ConfigAuthMethodWebauthnRelyingParty {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodWebauthnRelyingParty{}
	v.Name = s.Name
	v.Origins = make([]string, len(s.Origins))
	copy(v.Origins, s.Origins)
	return v
}

type ConfigAuthMethodWebauthnRelyingPartyComparisonExp struct {
	And     []*ConfigAuthMethodWebauthnRelyingPartyComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthMethodWebauthnRelyingPartyComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthMethodWebauthnRelyingPartyComparisonExp `json:"_or,omitempty"`
	Name    *ConfigStringComparisonExp                           `json:"name,omitempty"`
	Origins *ConfigUrlComparisonExp                              `json:"origins,omitempty"`
}

func (exp *ConfigAuthMethodWebauthnRelyingPartyComparisonExp) Matches(o *ConfigAuthMethodWebauthnRelyingParty) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodWebauthnRelyingParty{
			Origins: []string{},
		}
	}
	if !exp.Name.Matches(o.Name) {
		return false
	}
	{
		found := false
		for _, o := range o.Origins {
			if exp.Origins.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Origins != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthRedirections struct {
	ClientUrl   string   `json:"clientUrl,omitempty"`
	AllowedUrls []string `json:"allowedUrls,omitempty"`
}

func (o *ConfigAuthRedirections) GetClientUrl() string {
	if o == nil {
		o = &ConfigAuthRedirections{}
	}

	return o.ClientUrl
}

func (o *ConfigAuthRedirections) GetAllowedUrls() []string {
	if o == nil {
		o = &ConfigAuthRedirections{}
	}

	return o.AllowedUrls
}

type ConfigAuthRedirectionsUpdateInput struct {
	ClientUrl   *string  `json:"clientUrl,omitempty"`
	AllowedUrls []string `json:"allowedUrls,omitempty"`
}

func (s *ConfigAuthRedirections) Update(v *ConfigAuthRedirectionsUpdateInput) {
	if v == nil {
		return
	}
	if v.ClientUrl != nil {
		s.ClientUrl = *v.ClientUrl
	}
	if v.AllowedUrls != nil {
		s.AllowedUrls = make([]string, len(v.AllowedUrls))
		for i, e := range v.AllowedUrls {
			s.AllowedUrls[i] = e
		}
	}
}

type ConfigAuthRedirectionsInsertInput struct {
	ClientUrl   *string  `json:"clientUrl,omitempty"`
	AllowedUrls []string `json:"allowedUrls,omitempty"`
}

func (s *ConfigAuthRedirections) Insert(v *ConfigAuthRedirectionsInsertInput) {
	if v.ClientUrl != nil {
		s.ClientUrl = *v.ClientUrl
	}
	if v.AllowedUrls != nil {
		s.AllowedUrls = make([]string, len(v.AllowedUrls))
		for i, e := range v.AllowedUrls {
			s.AllowedUrls[i] = e
		}
	}
}

func (s *ConfigAuthRedirections) Clone() *ConfigAuthRedirections {
	if s == nil {
		return nil
	}

	v := &ConfigAuthRedirections{}
	v.ClientUrl = s.ClientUrl
	v.AllowedUrls = make([]string, len(s.AllowedUrls))
	copy(v.AllowedUrls, s.AllowedUrls)
	return v
}

type ConfigAuthRedirectionsComparisonExp struct {
	And         []*ConfigAuthRedirectionsComparisonExp `json:"_and,omitempty"`
	Not         *ConfigAuthRedirectionsComparisonExp   `json:"_not,omitempty"`
	Or          []*ConfigAuthRedirectionsComparisonExp `json:"_or,omitempty"`
	ClientUrl   *ConfigUrlComparisonExp                `json:"clientUrl,omitempty"`
	AllowedUrls *ConfigStringComparisonExp             `json:"allowedUrls,omitempty"`
}

func (exp *ConfigAuthRedirectionsComparisonExp) Matches(o *ConfigAuthRedirections) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthRedirections{
			AllowedUrls: []string{},
		}
	}
	if !exp.ClientUrl.Matches(o.ClientUrl) {
		return false
	}
	{
		found := false
		for _, o := range o.AllowedUrls {
			if exp.AllowedUrls.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.AllowedUrls != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthSession struct {
	AccessToken  *ConfigAuthSessionAccessToken  `json:"accessToken,omitempty"`
	RefreshToken *ConfigAuthSessionRefreshToken `json:"refreshToken,omitempty"`
}

func (o *ConfigAuthSession) GetAccessToken() *ConfigAuthSessionAccessToken {
	if o == nil {
		return nil
	}

	return o.AccessToken
}

func (o *ConfigAuthSession) GetRefreshToken() *ConfigAuthSessionRefreshToken {
	if o == nil {
		return nil
	}

	return o.RefreshToken
}

type ConfigAuthSessionUpdateInput struct {
	AccessToken  *ConfigAuthSessionAccessTokenUpdateInput  `json:"accessToken,omitempty"`
	RefreshToken *ConfigAuthSessionRefreshTokenUpdateInput `json:"refreshToken,omitempty"`
}

func (s *ConfigAuthSession) Update(v *ConfigAuthSessionUpdateInput) {
	if v == nil {
		return
	}
	if v.AccessToken != nil {
		if s.AccessToken == nil {
			s.AccessToken = &ConfigAuthSessionAccessToken{}
		}
		s.AccessToken.Update(v.AccessToken)
	}
	if v.RefreshToken != nil {
		if s.RefreshToken == nil {
			s.RefreshToken = &ConfigAuthSessionRefreshToken{}
		}
		s.RefreshToken.Update(v.RefreshToken)
	}
}

type ConfigAuthSessionInsertInput struct {
	AccessToken  *ConfigAuthSessionAccessTokenInsertInput  `json:"accessToken,omitempty"`
	RefreshToken *ConfigAuthSessionRefreshTokenInsertInput `json:"refreshToken,omitempty"`
}

func (s *ConfigAuthSession) Insert(v *ConfigAuthSessionInsertInput) {
	if v.AccessToken != nil {
		if s.AccessToken == nil {
			s.AccessToken = &ConfigAuthSessionAccessToken{}
		}
		s.AccessToken.Insert(v.AccessToken)
	}
	if v.RefreshToken != nil {
		if s.RefreshToken == nil {
			s.RefreshToken = &ConfigAuthSessionRefreshToken{}
		}
		s.RefreshToken.Insert(v.RefreshToken)
	}
}

func (s *ConfigAuthSession) Clone() *ConfigAuthSession {
	if s == nil {
		return nil
	}

	v := &ConfigAuthSession{}
	v.AccessToken = s.AccessToken.Clone()
	v.RefreshToken = s.RefreshToken.Clone()
	return v
}

type ConfigAuthSessionComparisonExp struct {
	And          []*ConfigAuthSessionComparisonExp           `json:"_and,omitempty"`
	Not          *ConfigAuthSessionComparisonExp             `json:"_not,omitempty"`
	Or           []*ConfigAuthSessionComparisonExp           `json:"_or,omitempty"`
	AccessToken  *ConfigAuthSessionAccessTokenComparisonExp  `json:"accessToken,omitempty"`
	RefreshToken *ConfigAuthSessionRefreshTokenComparisonExp `json:"refreshToken,omitempty"`
}

func (exp *ConfigAuthSessionComparisonExp) Matches(o *ConfigAuthSession) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthSession{
			AccessToken:  &ConfigAuthSessionAccessToken{},
			RefreshToken: &ConfigAuthSessionRefreshToken{},
		}
	}
	if !exp.AccessToken.Matches(o.AccessToken) {
		return false
	}
	if !exp.RefreshToken.Matches(o.RefreshToken) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthSessionAccessToken struct {
	ExpiresIn    uint32                                      `json:"expiresIn,omitempty"`
	CustomClaims []*ConfigAuthsessionaccessTokenCustomClaims `json:"customClaims,omitempty"`
}

func (o *ConfigAuthSessionAccessToken) GetExpiresIn() uint32 {
	if o == nil {
		o = &ConfigAuthSessionAccessToken{}
	}

	return o.ExpiresIn
}

func (o *ConfigAuthSessionAccessToken) GetCustomClaims() []*ConfigAuthsessionaccessTokenCustomClaims {
	if o == nil {
		o = &ConfigAuthSessionAccessToken{}
	}

	return o.CustomClaims
}

type ConfigAuthSessionAccessTokenUpdateInput struct {
	ExpiresIn    *uint32                                                `json:"expiresIn,omitempty"`
	CustomClaims []*ConfigAuthsessionaccessTokenCustomClaimsUpdateInput `json:"customClaims,omitempty"`
}

func (s *ConfigAuthSessionAccessToken) Update(v *ConfigAuthSessionAccessTokenUpdateInput) {
	if v == nil {
		return
	}
	if v.ExpiresIn != nil {
		s.ExpiresIn = *v.ExpiresIn
	}
	if v.CustomClaims != nil {
		s.CustomClaims = make([]*ConfigAuthsessionaccessTokenCustomClaims, len(v.CustomClaims))
		for i, e := range v.CustomClaims {
			v := &ConfigAuthsessionaccessTokenCustomClaims{}
			v.Update(e)
			s.CustomClaims[i] = v
		}
	}
}

type ConfigAuthSessionAccessTokenInsertInput struct {
	ExpiresIn    *uint32                                                `json:"expiresIn,omitempty"`
	CustomClaims []*ConfigAuthsessionaccessTokenCustomClaimsInsertInput `json:"customClaims,omitempty"`
}

func (s *ConfigAuthSessionAccessToken) Insert(v *ConfigAuthSessionAccessTokenInsertInput) {
	if v.ExpiresIn != nil {
		s.ExpiresIn = *v.ExpiresIn
	}
	if v.CustomClaims != nil {
		s.CustomClaims = make([]*ConfigAuthsessionaccessTokenCustomClaims, len(v.CustomClaims))
		for i, e := range v.CustomClaims {
			v := &ConfigAuthsessionaccessTokenCustomClaims{}
			v.Insert(e)
			s.CustomClaims[i] = v
		}
	}
}

func (s *ConfigAuthSessionAccessToken) Clone() *ConfigAuthSessionAccessToken {
	if s == nil {
		return nil
	}

	v := &ConfigAuthSessionAccessToken{}
	v.ExpiresIn = s.ExpiresIn
	v.CustomClaims = make([]*ConfigAuthsessionaccessTokenCustomClaims, len(s.CustomClaims))
	for i, e := range s.CustomClaims {
		v.CustomClaims[i] = e.Clone()
	}
	return v
}

type ConfigAuthSessionAccessTokenComparisonExp struct {
	And          []*ConfigAuthSessionAccessTokenComparisonExp           `json:"_and,omitempty"`
	Not          *ConfigAuthSessionAccessTokenComparisonExp             `json:"_not,omitempty"`
	Or           []*ConfigAuthSessionAccessTokenComparisonExp           `json:"_or,omitempty"`
	ExpiresIn    *ConfigUint32ComparisonExp                             `json:"expiresIn,omitempty"`
	CustomClaims *ConfigAuthsessionaccessTokenCustomClaimsComparisonExp `json:"customClaims,omitempty"`
}

func (exp *ConfigAuthSessionAccessTokenComparisonExp) Matches(o *ConfigAuthSessionAccessToken) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthSessionAccessToken{
			CustomClaims: []*ConfigAuthsessionaccessTokenCustomClaims{},
		}
	}
	if !exp.ExpiresIn.Matches(o.ExpiresIn) {
		return false
	}
	{
		found := false
		for _, o := range o.CustomClaims {
			if exp.CustomClaims.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.CustomClaims != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthSessionRefreshToken struct {
	ExpiresIn uint32 `json:"expiresIn,omitempty"`
}

func (o *ConfigAuthSessionRefreshToken) GetExpiresIn() uint32 {
	if o == nil {
		o = &ConfigAuthSessionRefreshToken{}
	}

	return o.ExpiresIn
}

type ConfigAuthSessionRefreshTokenUpdateInput struct {
	ExpiresIn *uint32 `json:"expiresIn,omitempty"`
}

func (s *ConfigAuthSessionRefreshToken) Update(v *ConfigAuthSessionRefreshTokenUpdateInput) {
	if v == nil {
		return
	}
	if v.ExpiresIn != nil {
		s.ExpiresIn = *v.ExpiresIn
	}
}

type ConfigAuthSessionRefreshTokenInsertInput struct {
	ExpiresIn *uint32 `json:"expiresIn,omitempty"`
}

func (s *ConfigAuthSessionRefreshToken) Insert(v *ConfigAuthSessionRefreshTokenInsertInput) {
	if v.ExpiresIn != nil {
		s.ExpiresIn = *v.ExpiresIn
	}
}

func (s *ConfigAuthSessionRefreshToken) Clone() *ConfigAuthSessionRefreshToken {
	if s == nil {
		return nil
	}

	v := &ConfigAuthSessionRefreshToken{}
	v.ExpiresIn = s.ExpiresIn
	return v
}

type ConfigAuthSessionRefreshTokenComparisonExp struct {
	And       []*ConfigAuthSessionRefreshTokenComparisonExp `json:"_and,omitempty"`
	Not       *ConfigAuthSessionRefreshTokenComparisonExp   `json:"_not,omitempty"`
	Or        []*ConfigAuthSessionRefreshTokenComparisonExp `json:"_or,omitempty"`
	ExpiresIn *ConfigUint32ComparisonExp                    `json:"expiresIn,omitempty"`
}

func (exp *ConfigAuthSessionRefreshTokenComparisonExp) Matches(o *ConfigAuthSessionRefreshToken) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthSessionRefreshToken{}
	}
	if !exp.ExpiresIn.Matches(o.ExpiresIn) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthSignUp struct {
	Enabled bool `json:"enabled,omitempty"`
}

func (o *ConfigAuthSignUp) GetEnabled() bool {
	if o == nil {
		o = &ConfigAuthSignUp{}
	}

	return o.Enabled
}

type ConfigAuthSignUpUpdateInput struct {
	Enabled *bool `json:"enabled,omitempty"`
}

func (s *ConfigAuthSignUp) Update(v *ConfigAuthSignUpUpdateInput) {
	if v == nil {
		return
	}
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
}

type ConfigAuthSignUpInsertInput struct {
	Enabled *bool `json:"enabled,omitempty"`
}

func (s *ConfigAuthSignUp) Insert(v *ConfigAuthSignUpInsertInput) {
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
}

func (s *ConfigAuthSignUp) Clone() *ConfigAuthSignUp {
	if s == nil {
		return nil
	}

	v := &ConfigAuthSignUp{}
	v.Enabled = s.Enabled
	return v
}

type ConfigAuthSignUpComparisonExp struct {
	And     []*ConfigAuthSignUpComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthSignUpComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthSignUpComparisonExp `json:"_or,omitempty"`
	Enabled *ConfigBooleanComparisonExp      `json:"enabled,omitempty"`
}

func (exp *ConfigAuthSignUpComparisonExp) Matches(o *ConfigAuthSignUp) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthSignUp{}
	}
	if !exp.Enabled.Matches(o.Enabled) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthTotp struct {
	Enabled bool   `json:"enabled,omitempty"`
	Issuer  string `json:"issuer,omitempty"`
}

func (o *ConfigAuthTotp) GetEnabled() bool {
	if o == nil {
		o = &ConfigAuthTotp{}
	}

	return o.Enabled
}

func (o *ConfigAuthTotp) GetIssuer() string {
	if o == nil {
		o = &ConfigAuthTotp{}
	}

	return o.Issuer
}

type ConfigAuthTotpUpdateInput struct {
	Enabled *bool   `json:"enabled,omitempty"`
	Issuer  *string `json:"issuer,omitempty"`
}

func (s *ConfigAuthTotp) Update(v *ConfigAuthTotpUpdateInput) {
	if v == nil {
		return
	}
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
	if v.Issuer != nil {
		s.Issuer = *v.Issuer
	}
}

type ConfigAuthTotpInsertInput struct {
	Enabled *bool   `json:"enabled,omitempty"`
	Issuer  *string `json:"issuer,omitempty"`
}

func (s *ConfigAuthTotp) Insert(v *ConfigAuthTotpInsertInput) {
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
	if v.Issuer != nil {
		s.Issuer = *v.Issuer
	}
}

func (s *ConfigAuthTotp) Clone() *ConfigAuthTotp {
	if s == nil {
		return nil
	}

	v := &ConfigAuthTotp{}
	v.Enabled = s.Enabled
	v.Issuer = s.Issuer
	return v
}

type ConfigAuthTotpComparisonExp struct {
	And     []*ConfigAuthTotpComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthTotpComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthTotpComparisonExp `json:"_or,omitempty"`
	Enabled *ConfigBooleanComparisonExp    `json:"enabled,omitempty"`
	Issuer  *ConfigStringComparisonExp     `json:"issuer,omitempty"`
}

func (exp *ConfigAuthTotpComparisonExp) Matches(o *ConfigAuthTotp) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthTotp{}
	}
	if !exp.Enabled.Matches(o.Enabled) {
		return false
	}
	if !exp.Issuer.Matches(o.Issuer) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthUser struct {
	Roles        *ConfigAuthUserRoles        `json:"roles,omitempty"`
	Locale       *ConfigAuthUserLocale       `json:"locale,omitempty"`
	Gravatar     *ConfigAuthUserGravatar     `json:"gravatar,omitempty"`
	Email        *ConfigAuthUserEmail        `json:"email,omitempty"`
	EmailDomains *ConfigAuthUserEmailDomains `json:"emailDomains,omitempty"`
}

func (o *ConfigAuthUser) GetRoles() *ConfigAuthUserRoles {
	if o == nil {
		return nil
	}

	return o.Roles
}

func (o *ConfigAuthUser) GetLocale() *ConfigAuthUserLocale {
	if o == nil {
		return nil
	}

	return o.Locale
}

func (o *ConfigAuthUser) GetGravatar() *ConfigAuthUserGravatar {
	if o == nil {
		return nil
	}

	return o.Gravatar
}

func (o *ConfigAuthUser) GetEmail() *ConfigAuthUserEmail {
	if o == nil {
		return nil
	}

	return o.Email
}

func (o *ConfigAuthUser) GetEmailDomains() *ConfigAuthUserEmailDomains {
	if o == nil {
		return nil
	}

	return o.EmailDomains
}

type ConfigAuthUserUpdateInput struct {
	Roles        *ConfigAuthUserRolesUpdateInput        `json:"roles,omitempty"`
	Locale       *ConfigAuthUserLocaleUpdateInput       `json:"locale,omitempty"`
	Gravatar     *ConfigAuthUserGravatarUpdateInput     `json:"gravatar,omitempty"`
	Email        *ConfigAuthUserEmailUpdateInput        `json:"email,omitempty"`
	EmailDomains *ConfigAuthUserEmailDomainsUpdateInput `json:"emailDomains,omitempty"`
}

func (s *ConfigAuthUser) Update(v *ConfigAuthUserUpdateInput) {
	if v == nil {
		return
	}
	if v.Roles != nil {
		if s.Roles == nil {
			s.Roles = &ConfigAuthUserRoles{}
		}
		s.Roles.Update(v.Roles)
	}
	if v.Locale != nil {
		if s.Locale == nil {
			s.Locale = &ConfigAuthUserLocale{}
		}
		s.Locale.Update(v.Locale)
	}
	if v.Gravatar != nil {
		if s.Gravatar == nil {
			s.Gravatar = &ConfigAuthUserGravatar{}
		}
		s.Gravatar.Update(v.Gravatar)
	}
	if v.Email != nil {
		if s.Email == nil {
			s.Email = &ConfigAuthUserEmail{}
		}
		s.Email.Update(v.Email)
	}
	if v.EmailDomains != nil {
		if s.EmailDomains == nil {
			s.EmailDomains = &ConfigAuthUserEmailDomains{}
		}
		s.EmailDomains.Update(v.EmailDomains)
	}
}

type ConfigAuthUserInsertInput struct {
	Roles        *ConfigAuthUserRolesInsertInput        `json:"roles,omitempty"`
	Locale       *ConfigAuthUserLocaleInsertInput       `json:"locale,omitempty"`
	Gravatar     *ConfigAuthUserGravatarInsertInput     `json:"gravatar,omitempty"`
	Email        *ConfigAuthUserEmailInsertInput        `json:"email,omitempty"`
	EmailDomains *ConfigAuthUserEmailDomainsInsertInput `json:"emailDomains,omitempty"`
}

func (s *ConfigAuthUser) Insert(v *ConfigAuthUserInsertInput) {
	if v.Roles != nil {
		if s.Roles == nil {
			s.Roles = &ConfigAuthUserRoles{}
		}
		s.Roles.Insert(v.Roles)
	}
	if v.Locale != nil {
		if s.Locale == nil {
			s.Locale = &ConfigAuthUserLocale{}
		}
		s.Locale.Insert(v.Locale)
	}
	if v.Gravatar != nil {
		if s.Gravatar == nil {
			s.Gravatar = &ConfigAuthUserGravatar{}
		}
		s.Gravatar.Insert(v.Gravatar)
	}
	if v.Email != nil {
		if s.Email == nil {
			s.Email = &ConfigAuthUserEmail{}
		}
		s.Email.Insert(v.Email)
	}
	if v.EmailDomains != nil {
		if s.EmailDomains == nil {
			s.EmailDomains = &ConfigAuthUserEmailDomains{}
		}
		s.EmailDomains.Insert(v.EmailDomains)
	}
}

func (s *ConfigAuthUser) Clone() *ConfigAuthUser {
	if s == nil {
		return nil
	}

	v := &ConfigAuthUser{}
	v.Roles = s.Roles.Clone()
	v.Locale = s.Locale.Clone()
	v.Gravatar = s.Gravatar.Clone()
	v.Email = s.Email.Clone()
	v.EmailDomains = s.EmailDomains.Clone()
	return v
}

type ConfigAuthUserComparisonExp struct {
	And          []*ConfigAuthUserComparisonExp           `json:"_and,omitempty"`
	Not          *ConfigAuthUserComparisonExp             `json:"_not,omitempty"`
	Or           []*ConfigAuthUserComparisonExp           `json:"_or,omitempty"`
	Roles        *ConfigAuthUserRolesComparisonExp        `json:"roles,omitempty"`
	Locale       *ConfigAuthUserLocaleComparisonExp       `json:"locale,omitempty"`
	Gravatar     *ConfigAuthUserGravatarComparisonExp     `json:"gravatar,omitempty"`
	Email        *ConfigAuthUserEmailComparisonExp        `json:"email,omitempty"`
	EmailDomains *ConfigAuthUserEmailDomainsComparisonExp `json:"emailDomains,omitempty"`
}

func (exp *ConfigAuthUserComparisonExp) Matches(o *ConfigAuthUser) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthUser{
			Roles:        &ConfigAuthUserRoles{},
			Locale:       &ConfigAuthUserLocale{},
			Gravatar:     &ConfigAuthUserGravatar{},
			Email:        &ConfigAuthUserEmail{},
			EmailDomains: &ConfigAuthUserEmailDomains{},
		}
	}
	if !exp.Roles.Matches(o.Roles) {
		return false
	}
	if !exp.Locale.Matches(o.Locale) {
		return false
	}
	if !exp.Gravatar.Matches(o.Gravatar) {
		return false
	}
	if !exp.Email.Matches(o.Email) {
		return false
	}
	if !exp.EmailDomains.Matches(o.EmailDomains) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthUserEmail struct {
	Allowed []string `json:"allowed,omitempty"`
	Blocked []string `json:"blocked,omitempty"`
}

func (o *ConfigAuthUserEmail) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserEmail{}
	}

	return o.Allowed
}

func (o *ConfigAuthUserEmail) GetBlocked() []string {
	if o == nil {
		o = &ConfigAuthUserEmail{}
	}

	return o.Blocked
}

type ConfigAuthUserEmailUpdateInput struct {
	Allowed []string `json:"allowed,omitempty"`
	Blocked []string `json:"blocked,omitempty"`
}

func (s *ConfigAuthUserEmail) Update(v *ConfigAuthUserEmailUpdateInput) {
	if v == nil {
		return
	}
	if v.Allowed != nil {
		s.Allowed = make([]string, len(v.Allowed))
		for i, e := range v.Allowed {
			s.Allowed[i] = e
		}
	}
	if v.Blocked != nil {
		s.Blocked = make([]string, len(v.Blocked))
		for i, e := range v.Blocked {
			s.Blocked[i] = e
		}
	}
}

type ConfigAuthUserEmailInsertInput struct {
	Allowed []string `json:"allowed,omitempty"`
	Blocked []string `json:"blocked,omitempty"`
}

func (s *ConfigAuthUserEmail) Insert(v *ConfigAuthUserEmailInsertInput) {
	if v.Allowed != nil {
		s.Allowed = make([]string, len(v.Allowed))
		for i, e := range v.Allowed {
			s.Allowed[i] = e
		}
	}
	if v.Blocked != nil {
		s.Blocked = make([]string, len(v.Blocked))
		for i, e := range v.Blocked {
			s.Blocked[i] = e
		}
	}
}

func (s *ConfigAuthUserEmail) Clone() *ConfigAuthUserEmail {
	if s == nil {
		return nil
	}

	v := &ConfigAuthUserEmail{}
	v.Allowed = make([]string, len(s.Allowed))
	copy(v.Allowed, s.Allowed)
	v.Blocked = make([]string, len(s.Blocked))
	copy(v.Blocked, s.Blocked)
	return v
}

type ConfigAuthUserEmailComparisonExp struct {
	And     []*ConfigAuthUserEmailComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthUserEmailComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthUserEmailComparisonExp `json:"_or,omitempty"`
	Allowed *ConfigEmailComparisonExp           `json:"allowed,omitempty"`
	Blocked *ConfigEmailComparisonExp           `json:"blocked,omitempty"`
}

func (exp *ConfigAuthUserEmailComparisonExp) Matches(o *ConfigAuthUserEmail) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthUserEmail{
			Allowed: []string{},
			Blocked: []string{},
		}
	}
	{
		found := false
		for _, o := range o.Allowed {
			if exp.Allowed.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Allowed != nil {
			return false
		}
	}
	{
		found := false
		for _, o := range o.Blocked {
			if exp.Blocked.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Blocked != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthUserEmailDomains struct {
	Allowed []string `json:"allowed,omitempty"`
	Blocked []string `json:"blocked,omitempty"`
}

func (o *ConfigAuthUserEmailDomains) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserEmailDomains{}
	}

	return o.Allowed
}

func (o *ConfigAuthUserEmailDomains) GetBlocked() []string {
	if o == nil {
		o = &ConfigAuthUserEmailDomains{}
	}

	return o.Blocked
}

type ConfigAuthUserEmailDomainsUpdateInput struct {
	Allowed []string `json:"allowed,omitempty"`
	Blocked []string `json:"blocked,omitempty"`
}

func (s *ConfigAuthUserEmailDomains) Update(v *ConfigAuthUserEmailDomainsUpdateInput) {
	if v == nil {
		return
	}
	if v.Allowed != nil {
		s.Allowed = make([]string, len(v.Allowed))
		for i, e := range v.Allowed {
			s.Allowed[i] = e
		}
	}
	if v.Blocked != nil {
		s.Blocked = make([]string, len(v.Blocked))
		for i, e := range v.Blocked {
			s.Blocked[i] = e
		}
	}
}

type ConfigAuthUserEmailDomainsInsertInput struct {
	Allowed []string `json:"allowed,omitempty"`
	Blocked []string `json:"blocked,omitempty"`
}

func (s *ConfigAuthUserEmailDomains) Insert(v *ConfigAuthUserEmailDomainsInsertInput) {
	if v.Allowed != nil {
		s.Allowed = make([]string, len(v.Allowed))
		for i, e := range v.Allowed {
			s.Allowed[i] = e
		}
	}
	if v.Blocked != nil {
		s.Blocked = make([]string, len(v.Blocked))
		for i, e := range v.Blocked {
			s.Blocked[i] = e
		}
	}
}

func (s *ConfigAuthUserEmailDomains) Clone() *ConfigAuthUserEmailDomains {
	if s == nil {
		return nil
	}

	v := &ConfigAuthUserEmailDomains{}
	v.Allowed = make([]string, len(s.Allowed))
	copy(v.Allowed, s.Allowed)
	v.Blocked = make([]string, len(s.Blocked))
	copy(v.Blocked, s.Blocked)
	return v
}

type ConfigAuthUserEmailDomainsComparisonExp struct {
	And     []*ConfigAuthUserEmailDomainsComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthUserEmailDomainsComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthUserEmailDomainsComparisonExp `json:"_or,omitempty"`
	Allowed *ConfigStringComparisonExp                 `json:"allowed,omitempty"`
	Blocked *ConfigStringComparisonExp                 `json:"blocked,omitempty"`
}

func (exp *ConfigAuthUserEmailDomainsComparisonExp) Matches(o *ConfigAuthUserEmailDomains) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthUserEmailDomains{
			Allowed: []string{},
			Blocked: []string{},
		}
	}
	{
		found := false
		for _, o := range o.Allowed {
			if exp.Allowed.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Allowed != nil {
			return false
		}
	}
	{
		found := false
		for _, o := range o.Blocked {
			if exp.Blocked.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Blocked != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthUserGravatar struct {
	Enabled bool   `json:"enabled,omitempty"`
	Default string `json:"default,omitempty"`
	Rating  string `json:"rating,omitempty"`
}

func (o *ConfigAuthUserGravatar) GetEnabled() bool {
	if o == nil {
		o = &ConfigAuthUserGravatar{}
	}

	return o.Enabled
}

func (o *ConfigAuthUserGravatar) GetDefault() string {
	if o == nil {
		o = &ConfigAuthUserGravatar{}
	}

	return o.Default
}

func (o *ConfigAuthUserGravatar) GetRating() string {
	if o == nil {
		o = &ConfigAuthUserGravatar{}
	}

	return o.Rating
}

type ConfigAuthUserGravatarUpdateInput struct {
	Enabled *bool   `json:"enabled,omitempty"`
	Default *string `json:"default,omitempty"`
	Rating  *string `json:"rating,omitempty"`
}

func (s *ConfigAuthUserGravatar) Update(v *ConfigAuthUserGravatarUpdateInput) {
	if v == nil {
		return
	}
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
	if v.Default != nil {
		s.Default = *v.Default
	}
	if v.Rating != nil {
		s.Rating = *v.Rating
	}
}

type ConfigAuthUserGravatarInsertInput struct {
	Enabled *bool   `json:"enabled,omitempty"`
	Default *string `json:"default,omitempty"`
	Rating  *string `json:"rating,omitempty"`
}

func (s *ConfigAuthUserGravatar) Insert(v *ConfigAuthUserGravatarInsertInput) {
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
	if v.Default != nil {
		s.Default = *v.Default
	}
	if v.Rating != nil {
		s.Rating = *v.Rating
	}
}

func (s *ConfigAuthUserGravatar) Clone() *ConfigAuthUserGravatar {
	if s == nil {
		return nil
	}

	v := &ConfigAuthUserGravatar{}
	v.Enabled = s.Enabled
	v.Default = s.Default
	v.Rating = s.Rating
	return v
}

type ConfigAuthUserGravatarComparisonExp struct {
	And     []*ConfigAuthUserGravatarComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthUserGravatarComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthUserGravatarComparisonExp `json:"_or,omitempty"`
	Enabled *ConfigBooleanComparisonExp            `json:"enabled,omitempty"`
	Default *ConfigStringComparisonExp             `json:"default,omitempty"`
	Rating  *ConfigStringComparisonExp             `json:"rating,omitempty"`
}

func (exp *ConfigAuthUserGravatarComparisonExp) Matches(o *ConfigAuthUserGravatar) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthUserGravatar{}
	}
	if !exp.Enabled.Matches(o.Enabled) {
		return false
	}
	if !exp.Default.Matches(o.Default) {
		return false
	}
	if !exp.Rating.Matches(o.Rating) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthUserLocale struct {
	Default string   `json:"default,omitempty"`
	Allowed []string `json:"allowed,omitempty"`
}

func (o *ConfigAuthUserLocale) GetDefault() string {
	if o == nil {
		o = &ConfigAuthUserLocale{}
	}

	return o.Default
}

func (o *ConfigAuthUserLocale) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserLocale{}
	}

	return o.Allowed
}

type ConfigAuthUserLocaleUpdateInput struct {
	Default *string  `json:"default,omitempty"`
	Allowed []string `json:"allowed,omitempty"`
}

func (s *ConfigAuthUserLocale) Update(v *ConfigAuthUserLocaleUpdateInput) {
	if v == nil {
		return
	}
	if v.Default != nil {
		s.Default = *v.Default
	}
	if v.Allowed != nil {
		s.Allowed = make([]string, len(v.Allowed))
		for i, e := range v.Allowed {
			s.Allowed[i] = e
		}
	}
}

type ConfigAuthUserLocaleInsertInput struct {
	Default *string  `json:"default,omitempty"`
	Allowed []string `json:"allowed,omitempty"`
}

func (s *ConfigAuthUserLocale) Insert(v *ConfigAuthUserLocaleInsertInput) {
	if v.Default != nil {
		s.Default = *v.Default
	}
	if v.Allowed != nil {
		s.Allowed = make([]string, len(v.Allowed))
		for i, e := range v.Allowed {
			s.Allowed[i] = e
		}
	}
}

func (s *ConfigAuthUserLocale) Clone() *ConfigAuthUserLocale {
	if s == nil {
		return nil
	}

	v := &ConfigAuthUserLocale{}
	v.Default = s.Default
	v.Allowed = make([]string, len(s.Allowed))
	copy(v.Allowed, s.Allowed)
	return v
}

type ConfigAuthUserLocaleComparisonExp struct {
	And     []*ConfigAuthUserLocaleComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthUserLocaleComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthUserLocaleComparisonExp `json:"_or,omitempty"`
	Default *ConfigLocaleComparisonExp           `json:"default,omitempty"`
	Allowed *ConfigLocaleComparisonExp           `json:"allowed,omitempty"`
}

func (exp *ConfigAuthUserLocaleComparisonExp) Matches(o *ConfigAuthUserLocale) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthUserLocale{
			Allowed: []string{},
		}
	}
	if !exp.Default.Matches(o.Default) {
		return false
	}
	{
		found := false
		for _, o := range o.Allowed {
			if exp.Allowed.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Allowed != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthUserRoles struct {
	Default string   `json:"default,omitempty"`
	Allowed []string `json:"allowed,omitempty"`
}

func (o *ConfigAuthUserRoles) GetDefault() string {
	if o == nil {
		o = &ConfigAuthUserRoles{}
	}

	return o.Default
}

func (o *ConfigAuthUserRoles) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserRoles{}
	}

	return o.Allowed
}

type ConfigAuthUserRolesUpdateInput struct {
	Default *string  `json:"default,omitempty"`
	Allowed []string `json:"allowed,omitempty"`
}

func (s *ConfigAuthUserRoles) Update(v *ConfigAuthUserRolesUpdateInput) {
	if v == nil {
		return
	}
	if v.Default != nil {
		s.Default = *v.Default
	}
	if v.Allowed != nil {
		s.Allowed = make([]string, len(v.Allowed))
		for i, e := range v.Allowed {
			s.Allowed[i] = e
		}
	}
}

type ConfigAuthUserRolesInsertInput struct {
	Default *string  `json:"default,omitempty"`
	Allowed []string `json:"allowed,omitempty"`
}

func (s *ConfigAuthUserRoles) Insert(v *ConfigAuthUserRolesInsertInput) {
	if v.Default != nil {
		s.Default = *v.Default
	}
	if v.Allowed != nil {
		s.Allowed = make([]string, len(v.Allowed))
		for i, e := range v.Allowed {
			s.Allowed[i] = e
		}
	}
}

func (s *ConfigAuthUserRoles) Clone() *ConfigAuthUserRoles {
	if s == nil {
		return nil
	}

	v := &ConfigAuthUserRoles{}
	v.Default = s.Default
	v.Allowed = make([]string, len(s.Allowed))
	copy(v.Allowed, s.Allowed)
	return v
}

type ConfigAuthUserRolesComparisonExp struct {
	And     []*ConfigAuthUserRolesComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthUserRolesComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthUserRolesComparisonExp `json:"_or,omitempty"`
	Default *ConfigUserRoleComparisonExp        `json:"default,omitempty"`
	Allowed *ConfigUserRoleComparisonExp        `json:"allowed,omitempty"`
}

func (exp *ConfigAuthUserRolesComparisonExp) Matches(o *ConfigAuthUserRoles) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthUserRoles{
			Allowed: []string{},
		}
	}
	if !exp.Default.Matches(o.Default) {
		return false
	}
	{
		found := false
		for _, o := range o.Allowed {
			if exp.Allowed.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Allowed != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthsessionaccessTokenCustomClaims struct {
	Key   string `json:"key,omitempty"`
	Value string `json:"value,omitempty"`
}

func (o *ConfigAuthsessionaccessTokenCustomClaims) GetKey() string {
	if o == nil {
		o = &ConfigAuthsessionaccessTokenCustomClaims{}
	}

	return o.Key
}

func (o *ConfigAuthsessionaccessTokenCustomClaims) GetValue() string {
	if o == nil {
		o = &ConfigAuthsessionaccessTokenCustomClaims{}
	}

	return o.Value
}

type ConfigAuthsessionaccessTokenCustomClaimsUpdateInput struct {
	Key   *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

func (s *ConfigAuthsessionaccessTokenCustomClaims) Update(v *ConfigAuthsessionaccessTokenCustomClaimsUpdateInput) {
	if v == nil {
		return
	}
	if v.Key != nil {
		s.Key = *v.Key
	}
	if v.Value != nil {
		s.Value = *v.Value
	}
}

type ConfigAuthsessionaccessTokenCustomClaimsInsertInput struct {
	Key   string `json:"key,omitempty"`
	Value string `json:"value,omitempty"`
}

func (s *ConfigAuthsessionaccessTokenCustomClaims) Insert(v *ConfigAuthsessionaccessTokenCustomClaimsInsertInput) {
	s.Key = v.Key
	s.Value = v.Value
}

func (s *ConfigAuthsessionaccessTokenCustomClaims) Clone() *ConfigAuthsessionaccessTokenCustomClaims {
	if s == nil {
		return nil
	}

	v := &ConfigAuthsessionaccessTokenCustomClaims{}
	v.Key = s.Key
	v.Value = s.Value
	return v
}

type ConfigAuthsessionaccessTokenCustomClaimsComparisonExp struct {
	And   []*ConfigAuthsessionaccessTokenCustomClaimsComparisonExp `json:"_and,omitempty"`
	Not   *ConfigAuthsessionaccessTokenCustomClaimsComparisonExp   `json:"_not,omitempty"`
	Or    []*ConfigAuthsessionaccessTokenCustomClaimsComparisonExp `json:"_or,omitempty"`
	Key   *ConfigStringComparisonExp                               `json:"key,omitempty"`
	Value *ConfigStringComparisonExp                               `json:"value,omitempty"`
}

func (exp *ConfigAuthsessionaccessTokenCustomClaimsComparisonExp) Matches(o *ConfigAuthsessionaccessTokenCustomClaims) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthsessionaccessTokenCustomClaims{}
	}
	if !exp.Key.Matches(o.Key) {
		return false
	}
	if !exp.Value.Matches(o.Value) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigConfig struct {
	Global    *ConfigGlobal    `json:"global,omitempty"`
	Hasura    *ConfigHasura    `json:"hasura,omitempty"`
	Functions *ConfigFunctions `json:"functions,omitempty"`
	Auth      *ConfigAuth      `json:"auth,omitempty"`
	Provider  *ConfigProvider  `json:"provider,omitempty"`
	Storage   *ConfigStorage   `json:"storage,omitempty"`
}

func (o *ConfigConfig) GetGlobal() *ConfigGlobal {
	if o == nil {
		return nil
	}

	return o.Global
}

func (o *ConfigConfig) GetHasura() *ConfigHasura {
	if o == nil {
		return nil
	}

	return o.Hasura
}

func (o *ConfigConfig) GetFunctions() *ConfigFunctions {
	if o == nil {
		return nil
	}

	return o.Functions
}

func (o *ConfigConfig) GetAuth() *ConfigAuth {
	if o == nil {
		return nil
	}

	return o.Auth
}

func (o *ConfigConfig) GetProvider() *ConfigProvider {
	if o == nil {
		return nil
	}

	return o.Provider
}

func (o *ConfigConfig) GetStorage() *ConfigStorage {
	if o == nil {
		return nil
	}

	return o.Storage
}

type ConfigConfigUpdateInput struct {
	Global    *ConfigGlobalUpdateInput    `json:"global,omitempty"`
	Hasura    *ConfigHasuraUpdateInput    `json:"hasura,omitempty"`
	Functions *ConfigFunctionsUpdateInput `json:"functions,omitempty"`
	Auth      *ConfigAuthUpdateInput      `json:"auth,omitempty"`
	Provider  *ConfigProviderUpdateInput  `json:"provider,omitempty"`
	Storage   *ConfigStorageUpdateInput   `json:"storage,omitempty"`
}

func (s *ConfigConfig) Update(v *ConfigConfigUpdateInput) {
	if v == nil {
		return
	}
	if v.Global != nil {
		if s.Global == nil {
			s.Global = &ConfigGlobal{}
		}
		s.Global.Update(v.Global)
	}
	if v.Hasura != nil {
		if s.Hasura == nil {
			s.Hasura = &ConfigHasura{}
		}
		s.Hasura.Update(v.Hasura)
	}
	if v.Functions != nil {
		if s.Functions == nil {
			s.Functions = &ConfigFunctions{}
		}
		s.Functions.Update(v.Functions)
	}
	if v.Auth != nil {
		if s.Auth == nil {
			s.Auth = &ConfigAuth{}
		}
		s.Auth.Update(v.Auth)
	}
	if v.Provider != nil {
		if s.Provider == nil {
			s.Provider = &ConfigProvider{}
		}
		s.Provider.Update(v.Provider)
	}
	if v.Storage != nil {
		if s.Storage == nil {
			s.Storage = &ConfigStorage{}
		}
		s.Storage.Update(v.Storage)
	}
}

type ConfigConfigInsertInput struct {
	Global    *ConfigGlobalInsertInput    `json:"global,omitempty"`
	Hasura    *ConfigHasuraInsertInput    `json:"hasura,omitempty"`
	Functions *ConfigFunctionsInsertInput `json:"functions,omitempty"`
	Auth      *ConfigAuthInsertInput      `json:"auth,omitempty"`
	Provider  *ConfigProviderInsertInput  `json:"provider,omitempty"`
	Storage   *ConfigStorageInsertInput   `json:"storage,omitempty"`
}

func (s *ConfigConfig) Insert(v *ConfigConfigInsertInput) {
	if v.Global != nil {
		if s.Global == nil {
			s.Global = &ConfigGlobal{}
		}
		s.Global.Insert(v.Global)
	}
	if v.Hasura != nil {
		if s.Hasura == nil {
			s.Hasura = &ConfigHasura{}
		}
		s.Hasura.Insert(v.Hasura)
	}
	if v.Functions != nil {
		if s.Functions == nil {
			s.Functions = &ConfigFunctions{}
		}
		s.Functions.Insert(v.Functions)
	}
	if v.Auth != nil {
		if s.Auth == nil {
			s.Auth = &ConfigAuth{}
		}
		s.Auth.Insert(v.Auth)
	}
	if v.Provider != nil {
		if s.Provider == nil {
			s.Provider = &ConfigProvider{}
		}
		s.Provider.Insert(v.Provider)
	}
	if v.Storage != nil {
		if s.Storage == nil {
			s.Storage = &ConfigStorage{}
		}
		s.Storage.Insert(v.Storage)
	}
}

func (s *ConfigConfig) Clone() *ConfigConfig {
	if s == nil {
		return nil
	}

	v := &ConfigConfig{}
	v.Global = s.Global.Clone()
	v.Hasura = s.Hasura.Clone()
	v.Functions = s.Functions.Clone()
	v.Auth = s.Auth.Clone()
	v.Provider = s.Provider.Clone()
	v.Storage = s.Storage.Clone()
	return v
}

type ConfigConfigComparisonExp struct {
	And       []*ConfigConfigComparisonExp  `json:"_and,omitempty"`
	Not       *ConfigConfigComparisonExp    `json:"_not,omitempty"`
	Or        []*ConfigConfigComparisonExp  `json:"_or,omitempty"`
	Global    *ConfigGlobalComparisonExp    `json:"global,omitempty"`
	Hasura    *ConfigHasuraComparisonExp    `json:"hasura,omitempty"`
	Functions *ConfigFunctionsComparisonExp `json:"functions,omitempty"`
	Auth      *ConfigAuthComparisonExp      `json:"auth,omitempty"`
	Provider  *ConfigProviderComparisonExp  `json:"provider,omitempty"`
	Storage   *ConfigStorageComparisonExp   `json:"storage,omitempty"`
}

func (exp *ConfigConfigComparisonExp) Matches(o *ConfigConfig) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigConfig{
			Global:    &ConfigGlobal{},
			Hasura:    &ConfigHasura{},
			Functions: &ConfigFunctions{},
			Auth:      &ConfigAuth{},
			Provider:  &ConfigProvider{},
			Storage:   &ConfigStorage{},
		}
	}
	if !exp.Global.Matches(o.Global) {
		return false
	}
	if !exp.Hasura.Matches(o.Hasura) {
		return false
	}
	if !exp.Functions.Matches(o.Functions) {
		return false
	}
	if !exp.Auth.Matches(o.Auth) {
		return false
	}
	if !exp.Provider.Matches(o.Provider) {
		return false
	}
	if !exp.Storage.Matches(o.Storage) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigEmailComparisonExp struct {
	Eq  *string  `json:"_eq,omitempty"`
	Neq *string  `json:"_neq,omitempty"`
	In  []string `json:"_in,omitempty"`
	Nin []string `json:"_nin,omitempty"`
}

func (exp *ConfigEmailComparisonExp) Matches(o string) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}

type ConfigEnvironmentVariable struct {
	Name  string `json:"name,omitempty"`
	Value string `json:"value,omitempty"`
}

func (o *ConfigEnvironmentVariable) GetName() string {
	if o == nil {
		o = &ConfigEnvironmentVariable{}
	}

	return o.Name
}

func (o *ConfigEnvironmentVariable) GetValue() string {
	if o == nil {
		o = &ConfigEnvironmentVariable{}
	}

	return o.Value
}

type ConfigEnvironmentVariableUpdateInput struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

func (s *ConfigEnvironmentVariable) Update(v *ConfigEnvironmentVariableUpdateInput) {
	if v == nil {
		return
	}
	if v.Name != nil {
		s.Name = *v.Name
	}
	if v.Value != nil {
		s.Value = *v.Value
	}
}

type ConfigEnvironmentVariableInsertInput struct {
	Name  string `json:"name,omitempty"`
	Value string `json:"value,omitempty"`
}

func (s *ConfigEnvironmentVariable) Insert(v *ConfigEnvironmentVariableInsertInput) {
	s.Name = v.Name
	s.Value = v.Value
}

func (s *ConfigEnvironmentVariable) Clone() *ConfigEnvironmentVariable {
	if s == nil {
		return nil
	}

	v := &ConfigEnvironmentVariable{}
	v.Name = s.Name
	v.Value = s.Value
	return v
}

type ConfigEnvironmentVariableComparisonExp struct {
	And   []*ConfigEnvironmentVariableComparisonExp `json:"_and,omitempty"`
	Not   *ConfigEnvironmentVariableComparisonExp   `json:"_not,omitempty"`
	Or    []*ConfigEnvironmentVariableComparisonExp `json:"_or,omitempty"`
	Name  *ConfigStringComparisonExp                `json:"name,omitempty"`
	Value *ConfigStringComparisonExp                `json:"value,omitempty"`
}

func (exp *ConfigEnvironmentVariableComparisonExp) Matches(o *ConfigEnvironmentVariable) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigEnvironmentVariable{}
	}
	if !exp.Name.Matches(o.Name) {
		return false
	}
	if !exp.Value.Matches(o.Value) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigFunctions struct {
	Node *ConfigFunctionsNode `json:"node,omitempty"`
}

func (o *ConfigFunctions) GetNode() *ConfigFunctionsNode {
	if o == nil {
		return nil
	}

	return o.Node
}

type ConfigFunctionsUpdateInput struct {
	Node *ConfigFunctionsNodeUpdateInput `json:"node,omitempty"`
}

func (s *ConfigFunctions) Update(v *ConfigFunctionsUpdateInput) {
	if v == nil {
		return
	}
	if v.Node != nil {
		if s.Node == nil {
			s.Node = &ConfigFunctionsNode{}
		}
		s.Node.Update(v.Node)
	}
}

type ConfigFunctionsInsertInput struct {
	Node *ConfigFunctionsNodeInsertInput `json:"node,omitempty"`
}

func (s *ConfigFunctions) Insert(v *ConfigFunctionsInsertInput) {
	if v.Node != nil {
		if s.Node == nil {
			s.Node = &ConfigFunctionsNode{}
		}
		s.Node.Insert(v.Node)
	}
}

func (s *ConfigFunctions) Clone() *ConfigFunctions {
	if s == nil {
		return nil
	}

	v := &ConfigFunctions{}
	v.Node = s.Node.Clone()
	return v
}

type ConfigFunctionsComparisonExp struct {
	And  []*ConfigFunctionsComparisonExp   `json:"_and,omitempty"`
	Not  *ConfigFunctionsComparisonExp     `json:"_not,omitempty"`
	Or   []*ConfigFunctionsComparisonExp   `json:"_or,omitempty"`
	Node *ConfigFunctionsNodeComparisonExp `json:"node,omitempty"`
}

func (exp *ConfigFunctionsComparisonExp) Matches(o *ConfigFunctions) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigFunctions{
			Node: &ConfigFunctionsNode{},
		}
	}
	if !exp.Node.Matches(o.Node) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigFunctionsNode struct {
	Version int `json:"version,omitempty"`
}

func (o *ConfigFunctionsNode) GetVersion() int {
	if o == nil {
		o = &ConfigFunctionsNode{}
	}

	return o.Version
}

type ConfigFunctionsNodeUpdateInput struct {
	Version *int `json:"version,omitempty"`
}

func (s *ConfigFunctionsNode) Update(v *ConfigFunctionsNodeUpdateInput) {
	if v == nil {
		return
	}
	if v.Version != nil {
		s.Version = *v.Version
	}
}

type ConfigFunctionsNodeInsertInput struct {
	Version *int `json:"version,omitempty"`
}

func (s *ConfigFunctionsNode) Insert(v *ConfigFunctionsNodeInsertInput) {
	if v.Version != nil {
		s.Version = *v.Version
	}
}

func (s *ConfigFunctionsNode) Clone() *ConfigFunctionsNode {
	if s == nil {
		return nil
	}

	v := &ConfigFunctionsNode{}
	v.Version = s.Version
	return v
}

type ConfigFunctionsNodeComparisonExp struct {
	And     []*ConfigFunctionsNodeComparisonExp `json:"_and,omitempty"`
	Not     *ConfigFunctionsNodeComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigFunctionsNodeComparisonExp `json:"_or,omitempty"`
	Version *ConfigIntComparisonExp             `json:"version,omitempty"`
}

func (exp *ConfigFunctionsNodeComparisonExp) Matches(o *ConfigFunctionsNode) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigFunctionsNode{}
	}
	if !exp.Version.Matches(o.Version) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigGlobal struct {
	Environment []*ConfigEnvironmentVariable `json:"environment,omitempty"`
	Name        string                       `json:"name,omitempty"`
}

func (o *ConfigGlobal) GetEnvironment() []*ConfigEnvironmentVariable {
	if o == nil {
		o = &ConfigGlobal{}
	}

	return o.Environment
}

func (o *ConfigGlobal) GetName() string {
	if o == nil {
		o = &ConfigGlobal{}
	}

	return o.Name
}

type ConfigGlobalUpdateInput struct {
	Environment []*ConfigEnvironmentVariableUpdateInput `json:"environment,omitempty"`
	Name        *string                                 `json:"name,omitempty"`
}

func (s *ConfigGlobal) Update(v *ConfigGlobalUpdateInput) {
	if v == nil {
		return
	}
	if v.Environment != nil {
		s.Environment = make([]*ConfigEnvironmentVariable, len(v.Environment))
		for i, e := range v.Environment {
			v := &ConfigEnvironmentVariable{}
			v.Update(e)
			s.Environment[i] = v
		}
	}
	if v.Name != nil {
		s.Name = *v.Name
	}
}

type ConfigGlobalInsertInput struct {
	Environment []*ConfigEnvironmentVariableInsertInput `json:"environment,omitempty"`
	Name        *string                                 `json:"name,omitempty"`
}

func (s *ConfigGlobal) Insert(v *ConfigGlobalInsertInput) {
	if v.Environment != nil {
		s.Environment = make([]*ConfigEnvironmentVariable, len(v.Environment))
		for i, e := range v.Environment {
			v := &ConfigEnvironmentVariable{}
			v.Insert(e)
			s.Environment[i] = v
		}
	}
	if v.Name != nil {
		s.Name = *v.Name
	}
}

func (s *ConfigGlobal) Clone() *ConfigGlobal {
	if s == nil {
		return nil
	}

	v := &ConfigGlobal{}
	v.Environment = make([]*ConfigEnvironmentVariable, len(s.Environment))
	for i, e := range s.Environment {
		v.Environment[i] = e.Clone()
	}
	v.Name = s.Name
	return v
}

type ConfigGlobalComparisonExp struct {
	And         []*ConfigGlobalComparisonExp            `json:"_and,omitempty"`
	Not         *ConfigGlobalComparisonExp              `json:"_not,omitempty"`
	Or          []*ConfigGlobalComparisonExp            `json:"_or,omitempty"`
	Environment *ConfigEnvironmentVariableComparisonExp `json:"environment,omitempty"`
	Name        *ConfigStringComparisonExp              `json:"name,omitempty"`
}

func (exp *ConfigGlobalComparisonExp) Matches(o *ConfigGlobal) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigGlobal{
			Environment: []*ConfigEnvironmentVariable{},
		}
	}
	{
		found := false
		for _, o := range o.Environment {
			if exp.Environment.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Environment != nil {
			return false
		}
	}
	if !exp.Name.Matches(o.Name) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigHasura struct {
	Version       string                `json:"version,omitempty"`
	JwtSecrets    []*ConfigJWTSecret    `json:"jwtSecrets,omitempty"`
	AdminSecret   string                `json:"adminSecret,omitempty"`
	WebhookSecret string                `json:"webhookSecret,omitempty"`
	Settings      *ConfigHasuraSettings `json:"settings,omitempty"`
}

func (o *ConfigHasura) GetVersion() string {
	if o == nil {
		o = &ConfigHasura{}
	}

	return o.Version
}

func (o *ConfigHasura) GetJwtSecrets() []*ConfigJWTSecret {
	if o == nil {
		o = &ConfigHasura{}
	}

	return o.JwtSecrets
}

func (o *ConfigHasura) GetAdminSecret() string {
	if o == nil {
		o = &ConfigHasura{}
	}

	return o.AdminSecret
}

func (o *ConfigHasura) GetWebhookSecret() string {
	if o == nil {
		o = &ConfigHasura{}
	}

	return o.WebhookSecret
}

func (o *ConfigHasura) GetSettings() *ConfigHasuraSettings {
	if o == nil {
		return nil
	}

	return o.Settings
}

type ConfigHasuraUpdateInput struct {
	Version       *string                          `json:"version,omitempty"`
	JwtSecrets    []*ConfigJWTSecretUpdateInput    `json:"jwtSecrets,omitempty"`
	AdminSecret   *string                          `json:"adminSecret,omitempty"`
	WebhookSecret *string                          `json:"webhookSecret,omitempty"`
	Settings      *ConfigHasuraSettingsUpdateInput `json:"settings,omitempty"`
}

func (s *ConfigHasura) Update(v *ConfigHasuraUpdateInput) {
	if v == nil {
		return
	}
	if v.Version != nil {
		s.Version = *v.Version
	}
	if v.JwtSecrets != nil {
		s.JwtSecrets = make([]*ConfigJWTSecret, len(v.JwtSecrets))
		for i, e := range v.JwtSecrets {
			v := &ConfigJWTSecret{}
			v.Update(e)
			s.JwtSecrets[i] = v
		}
	}
	if v.AdminSecret != nil {
		s.AdminSecret = *v.AdminSecret
	}
	if v.WebhookSecret != nil {
		s.WebhookSecret = *v.WebhookSecret
	}
	if v.Settings != nil {
		if s.Settings == nil {
			s.Settings = &ConfigHasuraSettings{}
		}
		s.Settings.Update(v.Settings)
	}
}

type ConfigHasuraInsertInput struct {
	Version       *string                          `json:"version,omitempty"`
	JwtSecrets    []*ConfigJWTSecretInsertInput    `json:"jwtSecrets,omitempty"`
	AdminSecret   string                           `json:"adminSecret,omitempty"`
	WebhookSecret string                           `json:"webhookSecret,omitempty"`
	Settings      *ConfigHasuraSettingsInsertInput `json:"settings,omitempty"`
}

func (s *ConfigHasura) Insert(v *ConfigHasuraInsertInput) {
	if v.Version != nil {
		s.Version = *v.Version
	}
	if v.JwtSecrets != nil {
		s.JwtSecrets = make([]*ConfigJWTSecret, len(v.JwtSecrets))
		for i, e := range v.JwtSecrets {
			v := &ConfigJWTSecret{}
			v.Insert(e)
			s.JwtSecrets[i] = v
		}
	}
	s.AdminSecret = v.AdminSecret
	s.WebhookSecret = v.WebhookSecret
	if v.Settings != nil {
		if s.Settings == nil {
			s.Settings = &ConfigHasuraSettings{}
		}
		s.Settings.Insert(v.Settings)
	}
}

func (s *ConfigHasura) Clone() *ConfigHasura {
	if s == nil {
		return nil
	}

	v := &ConfigHasura{}
	v.Version = s.Version
	v.JwtSecrets = make([]*ConfigJWTSecret, len(s.JwtSecrets))
	for i, e := range s.JwtSecrets {
		v.JwtSecrets[i] = e.Clone()
	}
	v.AdminSecret = s.AdminSecret
	v.WebhookSecret = s.WebhookSecret
	v.Settings = s.Settings.Clone()
	return v
}

type ConfigHasuraComparisonExp struct {
	And           []*ConfigHasuraComparisonExp       `json:"_and,omitempty"`
	Not           *ConfigHasuraComparisonExp         `json:"_not,omitempty"`
	Or            []*ConfigHasuraComparisonExp       `json:"_or,omitempty"`
	Version       *ConfigStringComparisonExp         `json:"version,omitempty"`
	JwtSecrets    *ConfigJWTSecretComparisonExp      `json:"jwtSecrets,omitempty"`
	AdminSecret   *ConfigStringComparisonExp         `json:"adminSecret,omitempty"`
	WebhookSecret *ConfigStringComparisonExp         `json:"webhookSecret,omitempty"`
	Settings      *ConfigHasuraSettingsComparisonExp `json:"settings,omitempty"`
}

func (exp *ConfigHasuraComparisonExp) Matches(o *ConfigHasura) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigHasura{
			JwtSecrets: []*ConfigJWTSecret{},
			Settings:   &ConfigHasuraSettings{},
		}
	}
	if !exp.Version.Matches(o.Version) {
		return false
	}
	{
		found := false
		for _, o := range o.JwtSecrets {
			if exp.JwtSecrets.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.JwtSecrets != nil {
			return false
		}
	}
	if !exp.AdminSecret.Matches(o.AdminSecret) {
		return false
	}
	if !exp.WebhookSecret.Matches(o.WebhookSecret) {
		return false
	}
	if !exp.Settings.Matches(o.Settings) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigHasuraSettings struct {
	EnableRemoteSchemaPermissions bool `json:"enableRemoteSchemaPermissions,omitempty"`
}

func (o *ConfigHasuraSettings) GetEnableRemoteSchemaPermissions() bool {
	if o == nil {
		o = &ConfigHasuraSettings{}
	}

	return o.EnableRemoteSchemaPermissions
}

type ConfigHasuraSettingsUpdateInput struct {
	EnableRemoteSchemaPermissions *bool `json:"enableRemoteSchemaPermissions,omitempty"`
}

func (s *ConfigHasuraSettings) Update(v *ConfigHasuraSettingsUpdateInput) {
	if v == nil {
		return
	}
	if v.EnableRemoteSchemaPermissions != nil {
		s.EnableRemoteSchemaPermissions = *v.EnableRemoteSchemaPermissions
	}
}

type ConfigHasuraSettingsInsertInput struct {
	EnableRemoteSchemaPermissions *bool `json:"enableRemoteSchemaPermissions,omitempty"`
}

func (s *ConfigHasuraSettings) Insert(v *ConfigHasuraSettingsInsertInput) {
	if v.EnableRemoteSchemaPermissions != nil {
		s.EnableRemoteSchemaPermissions = *v.EnableRemoteSchemaPermissions
	}
}

func (s *ConfigHasuraSettings) Clone() *ConfigHasuraSettings {
	if s == nil {
		return nil
	}

	v := &ConfigHasuraSettings{}
	v.EnableRemoteSchemaPermissions = s.EnableRemoteSchemaPermissions
	return v
}

type ConfigHasuraSettingsComparisonExp struct {
	And                           []*ConfigHasuraSettingsComparisonExp `json:"_and,omitempty"`
	Not                           *ConfigHasuraSettingsComparisonExp   `json:"_not,omitempty"`
	Or                            []*ConfigHasuraSettingsComparisonExp `json:"_or,omitempty"`
	EnableRemoteSchemaPermissions *ConfigBooleanComparisonExp          `json:"enableRemoteSchemaPermissions,omitempty"`
}

func (exp *ConfigHasuraSettingsComparisonExp) Matches(o *ConfigHasuraSettings) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigHasuraSettings{}
	}
	if !exp.EnableRemoteSchemaPermissions.Matches(o.EnableRemoteSchemaPermissions) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigJWTSecret struct {
	Type                string `json:"type,omitempty"`
	Key                 string `json:"key,omitempty"`
	JwkUrl              string `json:"jwk_url,omitempty"`
	ClaimsFormat        string `json:"claims_format,omitempty"`
	Audience            string `json:"audience,omitempty"`
	Issuer              string `json:"issuer,omitempty"`
	AllowedSkew         uint32 `json:"allowed_skew,omitempty"`
	Header              string `json:"header,omitempty"`
	ClaimsNamespace     string `json:"claims_namespace,omitempty"`
	ClaimsNamespacePath string `json:"claims_namespace_path,omitempty"`
}

func (o *ConfigJWTSecret) GetType() string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}

	return o.Type
}

func (o *ConfigJWTSecret) GetKey() string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}

	return o.Key
}

func (o *ConfigJWTSecret) GetJwkUrl() string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}

	return o.JwkUrl
}

func (o *ConfigJWTSecret) GetClaimsFormat() string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}

	return o.ClaimsFormat
}

func (o *ConfigJWTSecret) GetAudience() string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}

	return o.Audience
}

func (o *ConfigJWTSecret) GetIssuer() string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}

	return o.Issuer
}

func (o *ConfigJWTSecret) GetAllowedSkew() uint32 {
	if o == nil {
		o = &ConfigJWTSecret{}
	}

	return o.AllowedSkew
}

func (o *ConfigJWTSecret) GetHeader() string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}

	return o.Header
}

func (o *ConfigJWTSecret) GetClaimsNamespace() string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}

	return o.ClaimsNamespace
}

func (o *ConfigJWTSecret) GetClaimsNamespacePath() string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}

	return o.ClaimsNamespacePath
}

type ConfigJWTSecretUpdateInput struct {
	Type                *string `json:"type,omitempty"`
	Key                 *string `json:"key,omitempty"`
	JwkUrl              *string `json:"jwk_url,omitempty"`
	ClaimsFormat        *string `json:"claims_format,omitempty"`
	Audience            *string `json:"audience,omitempty"`
	Issuer              *string `json:"issuer,omitempty"`
	AllowedSkew         *uint32 `json:"allowed_skew,omitempty"`
	Header              *string `json:"header,omitempty"`
	ClaimsNamespace     *string `json:"claims_namespace,omitempty"`
	ClaimsNamespacePath *string `json:"claims_namespace_path,omitempty"`
}

func (s *ConfigJWTSecret) Update(v *ConfigJWTSecretUpdateInput) {
	if v == nil {
		return
	}
	if v.Type != nil {
		s.Type = *v.Type
	}
	if v.Key != nil {
		s.Key = *v.Key
	}
	if v.JwkUrl != nil {
		s.JwkUrl = *v.JwkUrl
	}
	if v.ClaimsFormat != nil {
		s.ClaimsFormat = *v.ClaimsFormat
	}
	if v.Audience != nil {
		s.Audience = *v.Audience
	}
	if v.Issuer != nil {
		s.Issuer = *v.Issuer
	}
	if v.AllowedSkew != nil {
		s.AllowedSkew = *v.AllowedSkew
	}
	if v.Header != nil {
		s.Header = *v.Header
	}
	if v.ClaimsNamespace != nil {
		s.ClaimsNamespace = *v.ClaimsNamespace
	}
	if v.ClaimsNamespacePath != nil {
		s.ClaimsNamespacePath = *v.ClaimsNamespacePath
	}
}

type ConfigJWTSecretInsertInput struct {
	Type                *string `json:"type,omitempty"`
	Key                 *string `json:"key,omitempty"`
	JwkUrl              *string `json:"jwk_url,omitempty"`
	ClaimsFormat        *string `json:"claims_format,omitempty"`
	Audience            *string `json:"audience,omitempty"`
	Issuer              *string `json:"issuer,omitempty"`
	AllowedSkew         *uint32 `json:"allowed_skew,omitempty"`
	Header              *string `json:"header,omitempty"`
	ClaimsNamespace     *string `json:"claims_namespace,omitempty"`
	ClaimsNamespacePath *string `json:"claims_namespace_path,omitempty"`
}

func (s *ConfigJWTSecret) Insert(v *ConfigJWTSecretInsertInput) {
	if v.Type != nil {
		s.Type = *v.Type
	}
	if v.Key != nil {
		s.Key = *v.Key
	}
	if v.JwkUrl != nil {
		s.JwkUrl = *v.JwkUrl
	}
	if v.ClaimsFormat != nil {
		s.ClaimsFormat = *v.ClaimsFormat
	}
	if v.Audience != nil {
		s.Audience = *v.Audience
	}
	if v.Issuer != nil {
		s.Issuer = *v.Issuer
	}
	if v.AllowedSkew != nil {
		s.AllowedSkew = *v.AllowedSkew
	}
	if v.Header != nil {
		s.Header = *v.Header
	}
	if v.ClaimsNamespace != nil {
		s.ClaimsNamespace = *v.ClaimsNamespace
	}
	if v.ClaimsNamespacePath != nil {
		s.ClaimsNamespacePath = *v.ClaimsNamespacePath
	}
}

func (s *ConfigJWTSecret) Clone() *ConfigJWTSecret {
	if s == nil {
		return nil
	}

	v := &ConfigJWTSecret{}
	v.Type = s.Type
	v.Key = s.Key
	v.JwkUrl = s.JwkUrl
	v.ClaimsFormat = s.ClaimsFormat
	v.Audience = s.Audience
	v.Issuer = s.Issuer
	v.AllowedSkew = s.AllowedSkew
	v.Header = s.Header
	v.ClaimsNamespace = s.ClaimsNamespace
	v.ClaimsNamespacePath = s.ClaimsNamespacePath
	return v
}

type ConfigJWTSecretComparisonExp struct {
	And                 []*ConfigJWTSecretComparisonExp `json:"_and,omitempty"`
	Not                 *ConfigJWTSecretComparisonExp   `json:"_not,omitempty"`
	Or                  []*ConfigJWTSecretComparisonExp `json:"_or,omitempty"`
	Type                *ConfigStringComparisonExp      `json:"type,omitempty"`
	Key                 *ConfigStringComparisonExp      `json:"key,omitempty"`
	JwkUrl              *ConfigUrlComparisonExp         `json:"jwk_url,omitempty"`
	ClaimsFormat        *ConfigStringComparisonExp      `json:"claims_format,omitempty"`
	Audience            *ConfigStringComparisonExp      `json:"audience,omitempty"`
	Issuer              *ConfigStringComparisonExp      `json:"issuer,omitempty"`
	AllowedSkew         *ConfigUint32ComparisonExp      `json:"allowed_skew,omitempty"`
	Header              *ConfigStringComparisonExp      `json:"header,omitempty"`
	ClaimsNamespace     *ConfigStringComparisonExp      `json:"claims_namespace,omitempty"`
	ClaimsNamespacePath *ConfigStringComparisonExp      `json:"claims_namespace_path,omitempty"`
}

func (exp *ConfigJWTSecretComparisonExp) Matches(o *ConfigJWTSecret) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigJWTSecret{}
	}
	if !exp.Type.Matches(o.Type) {
		return false
	}
	if !exp.Key.Matches(o.Key) {
		return false
	}
	if !exp.JwkUrl.Matches(o.JwkUrl) {
		return false
	}
	if !exp.ClaimsFormat.Matches(o.ClaimsFormat) {
		return false
	}
	if !exp.Audience.Matches(o.Audience) {
		return false
	}
	if !exp.Issuer.Matches(o.Issuer) {
		return false
	}
	if !exp.AllowedSkew.Matches(o.AllowedSkew) {
		return false
	}
	if !exp.Header.Matches(o.Header) {
		return false
	}
	if !exp.ClaimsNamespace.Matches(o.ClaimsNamespace) {
		return false
	}
	if !exp.ClaimsNamespacePath.Matches(o.ClaimsNamespacePath) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigLocaleComparisonExp struct {
	Eq  *string  `json:"_eq,omitempty"`
	Neq *string  `json:"_neq,omitempty"`
	In  []string `json:"_in,omitempty"`
	Nin []string `json:"_nin,omitempty"`
}

func (exp *ConfigLocaleComparisonExp) Matches(o string) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}

type ConfigPortComparisonExp struct {
	Eq  *uint16  `json:"_eq,omitempty"`
	Neq *uint16  `json:"_neq,omitempty"`
	In  []uint16 `json:"_in,omitempty"`
	Nin []uint16 `json:"_nin,omitempty"`
}

func (exp *ConfigPortComparisonExp) Matches(o uint16) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}

type ConfigPostgresConnectionSettings struct {
	Type     string `json:"type,omitempty"`
	Database string `json:"database,omitempty"`
	Host     string `json:"host,omitempty"`
	Port     uint16 `json:"port,omitempty"`
	User     string `json:"user,omitempty"`
	Password string `json:"password,omitempty"`
}

func (o *ConfigPostgresConnectionSettings) GetType() string {
	if o == nil {
		o = &ConfigPostgresConnectionSettings{}
	}

	return o.Type
}

func (o *ConfigPostgresConnectionSettings) GetDatabase() string {
	if o == nil {
		o = &ConfigPostgresConnectionSettings{}
	}

	return o.Database
}

func (o *ConfigPostgresConnectionSettings) GetHost() string {
	if o == nil {
		o = &ConfigPostgresConnectionSettings{}
	}

	return o.Host
}

func (o *ConfigPostgresConnectionSettings) GetPort() uint16 {
	if o == nil {
		o = &ConfigPostgresConnectionSettings{}
	}

	return o.Port
}

func (o *ConfigPostgresConnectionSettings) GetUser() string {
	if o == nil {
		o = &ConfigPostgresConnectionSettings{}
	}

	return o.User
}

func (o *ConfigPostgresConnectionSettings) GetPassword() string {
	if o == nil {
		o = &ConfigPostgresConnectionSettings{}
	}

	return o.Password
}

type ConfigPostgresConnectionSettingsUpdateInput struct {
	Type     *string `json:"type,omitempty"`
	Database *string `json:"database,omitempty"`
	Host     *string `json:"host,omitempty"`
	Port     *uint16 `json:"port,omitempty"`
	User     *string `json:"user,omitempty"`
	Password *string `json:"password,omitempty"`
}

func (s *ConfigPostgresConnectionSettings) Update(v *ConfigPostgresConnectionSettingsUpdateInput) {
	if v == nil {
		return
	}
	if v.Type != nil {
		s.Type = *v.Type
	}
	if v.Database != nil {
		s.Database = *v.Database
	}
	if v.Host != nil {
		s.Host = *v.Host
	}
	if v.Port != nil {
		s.Port = *v.Port
	}
	if v.User != nil {
		s.User = *v.User
	}
	if v.Password != nil {
		s.Password = *v.Password
	}
}

type ConfigPostgresConnectionSettingsInsertInput struct {
	Type     *string `json:"type,omitempty"`
	Database *string `json:"database,omitempty"`
	Host     *string `json:"host,omitempty"`
	Port     *uint16 `json:"port,omitempty"`
	User     *string `json:"user,omitempty"`
	Password *string `json:"password,omitempty"`
}

func (s *ConfigPostgresConnectionSettings) Insert(v *ConfigPostgresConnectionSettingsInsertInput) {
	if v.Type != nil {
		s.Type = *v.Type
	}
	if v.Database != nil {
		s.Database = *v.Database
	}
	if v.Host != nil {
		s.Host = *v.Host
	}
	if v.Port != nil {
		s.Port = *v.Port
	}
	if v.User != nil {
		s.User = *v.User
	}
	if v.Password != nil {
		s.Password = *v.Password
	}
}

func (s *ConfigPostgresConnectionSettings) Clone() *ConfigPostgresConnectionSettings {
	if s == nil {
		return nil
	}

	v := &ConfigPostgresConnectionSettings{}
	v.Type = s.Type
	v.Database = s.Database
	v.Host = s.Host
	v.Port = s.Port
	v.User = s.User
	v.Password = s.Password
	return v
}

type ConfigPostgresConnectionSettingsComparisonExp struct {
	And      []*ConfigPostgresConnectionSettingsComparisonExp `json:"_and,omitempty"`
	Not      *ConfigPostgresConnectionSettingsComparisonExp   `json:"_not,omitempty"`
	Or       []*ConfigPostgresConnectionSettingsComparisonExp `json:"_or,omitempty"`
	Type     *ConfigStringComparisonExp                       `json:"type,omitempty"`
	Database *ConfigStringComparisonExp                       `json:"database,omitempty"`
	Host     *ConfigStringComparisonExp                       `json:"host,omitempty"`
	Port     *ConfigPortComparisonExp                         `json:"port,omitempty"`
	User     *ConfigStringComparisonExp                       `json:"user,omitempty"`
	Password *ConfigStringComparisonExp                       `json:"password,omitempty"`
}

func (exp *ConfigPostgresConnectionSettingsComparisonExp) Matches(o *ConfigPostgresConnectionSettings) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigPostgresConnectionSettings{}
	}
	if !exp.Type.Matches(o.Type) {
		return false
	}
	if !exp.Database.Matches(o.Database) {
		return false
	}
	if !exp.Host.Matches(o.Host) {
		return false
	}
	if !exp.Port.Matches(o.Port) {
		return false
	}
	if !exp.User.Matches(o.User) {
		return false
	}
	if !exp.Password.Matches(o.Password) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigProvider struct {
	Smtp *ConfigSmtp `json:"smtp,omitempty"`
	Sms  *ConfigSms  `json:"sms,omitempty"`
}

func (o *ConfigProvider) GetSmtp() *ConfigSmtp {
	if o == nil {
		return nil
	}

	return o.Smtp
}

func (o *ConfigProvider) GetSms() *ConfigSms {
	if o == nil {
		return nil
	}

	return o.Sms
}

type ConfigProviderUpdateInput struct {
	Smtp *ConfigSmtpUpdateInput `json:"smtp,omitempty"`
	Sms  *ConfigSmsUpdateInput  `json:"sms,omitempty"`
}

func (s *ConfigProvider) Update(v *ConfigProviderUpdateInput) {
	if v == nil {
		return
	}
	if v.Smtp != nil {
		if s.Smtp == nil {
			s.Smtp = &ConfigSmtp{}
		}
		s.Smtp.Update(v.Smtp)
	}
	if v.Sms != nil {
		if s.Sms == nil {
			s.Sms = &ConfigSms{}
		}
		s.Sms.Update(v.Sms)
	}
}

type ConfigProviderInsertInput struct {
	Smtp *ConfigSmtpInsertInput `json:"smtp,omitempty"`
	Sms  *ConfigSmsInsertInput  `json:"sms,omitempty"`
}

func (s *ConfigProvider) Insert(v *ConfigProviderInsertInput) {
	if v.Smtp != nil {
		if s.Smtp == nil {
			s.Smtp = &ConfigSmtp{}
		}
		s.Smtp.Insert(v.Smtp)
	}
	if v.Sms != nil {
		if s.Sms == nil {
			s.Sms = &ConfigSms{}
		}
		s.Sms.Insert(v.Sms)
	}
}

func (s *ConfigProvider) Clone() *ConfigProvider {
	if s == nil {
		return nil
	}

	v := &ConfigProvider{}
	v.Smtp = s.Smtp.Clone()
	v.Sms = s.Sms.Clone()
	return v
}

type ConfigProviderComparisonExp struct {
	And  []*ConfigProviderComparisonExp `json:"_and,omitempty"`
	Not  *ConfigProviderComparisonExp   `json:"_not,omitempty"`
	Or   []*ConfigProviderComparisonExp `json:"_or,omitempty"`
	Smtp *ConfigSmtpComparisonExp       `json:"smtp,omitempty"`
	Sms  *ConfigSmsComparisonExp        `json:"sms,omitempty"`
}

func (exp *ConfigProviderComparisonExp) Matches(o *ConfigProvider) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigProvider{
			Smtp: &ConfigSmtp{},
			Sms:  &ConfigSms{},
		}
	}
	if !exp.Smtp.Matches(o.Smtp) {
		return false
	}
	if !exp.Sms.Matches(o.Sms) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSms struct {
	Provider           string `json:"provider,omitempty"`
	AccountSid         string `json:"accountSid,omitempty"`
	AuthToken          string `json:"authToken,omitempty"`
	MessagingServiceId string `json:"messagingServiceId,omitempty"`
}

func (o *ConfigSms) GetProvider() string {
	if o == nil {
		o = &ConfigSms{}
	}

	return o.Provider
}

func (o *ConfigSms) GetAccountSid() string {
	if o == nil {
		o = &ConfigSms{}
	}

	return o.AccountSid
}

func (o *ConfigSms) GetAuthToken() string {
	if o == nil {
		o = &ConfigSms{}
	}

	return o.AuthToken
}

func (o *ConfigSms) GetMessagingServiceId() string {
	if o == nil {
		o = &ConfigSms{}
	}

	return o.MessagingServiceId
}

type ConfigSmsUpdateInput struct {
	Provider           *string `json:"provider,omitempty"`
	AccountSid         *string `json:"accountSid,omitempty"`
	AuthToken          *string `json:"authToken,omitempty"`
	MessagingServiceId *string `json:"messagingServiceId,omitempty"`
}

func (s *ConfigSms) Update(v *ConfigSmsUpdateInput) {
	if v == nil {
		return
	}
	if v.Provider != nil {
		s.Provider = *v.Provider
	}
	if v.AccountSid != nil {
		s.AccountSid = *v.AccountSid
	}
	if v.AuthToken != nil {
		s.AuthToken = *v.AuthToken
	}
	if v.MessagingServiceId != nil {
		s.MessagingServiceId = *v.MessagingServiceId
	}
}

type ConfigSmsInsertInput struct {
	Provider           *string `json:"provider,omitempty"`
	AccountSid         string  `json:"accountSid,omitempty"`
	AuthToken          string  `json:"authToken,omitempty"`
	MessagingServiceId string  `json:"messagingServiceId,omitempty"`
}

func (s *ConfigSms) Insert(v *ConfigSmsInsertInput) {
	if v.Provider != nil {
		s.Provider = *v.Provider
	}
	s.AccountSid = v.AccountSid
	s.AuthToken = v.AuthToken
	s.MessagingServiceId = v.MessagingServiceId
}

func (s *ConfigSms) Clone() *ConfigSms {
	if s == nil {
		return nil
	}

	v := &ConfigSms{}
	v.Provider = s.Provider
	v.AccountSid = s.AccountSid
	v.AuthToken = s.AuthToken
	v.MessagingServiceId = s.MessagingServiceId
	return v
}

type ConfigSmsComparisonExp struct {
	And                []*ConfigSmsComparisonExp  `json:"_and,omitempty"`
	Not                *ConfigSmsComparisonExp    `json:"_not,omitempty"`
	Or                 []*ConfigSmsComparisonExp  `json:"_or,omitempty"`
	Provider           *ConfigStringComparisonExp `json:"provider,omitempty"`
	AccountSid         *ConfigStringComparisonExp `json:"accountSid,omitempty"`
	AuthToken          *ConfigStringComparisonExp `json:"authToken,omitempty"`
	MessagingServiceId *ConfigStringComparisonExp `json:"messagingServiceId,omitempty"`
}

func (exp *ConfigSmsComparisonExp) Matches(o *ConfigSms) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSms{}
	}
	if !exp.Provider.Matches(o.Provider) {
		return false
	}
	if !exp.AccountSid.Matches(o.AccountSid) {
		return false
	}
	if !exp.AuthToken.Matches(o.AuthToken) {
		return false
	}
	if !exp.MessagingServiceId.Matches(o.MessagingServiceId) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSmtp struct {
	User     string `json:"user,omitempty"`
	Password string `json:"password,omitempty"`
	Sender   string `json:"sender,omitempty"`
	Host     string `json:"host,omitempty"`
	Port     uint16 `json:"port,omitempty"`
	Secure   bool   `json:"secure,omitempty"`
	Method   string `json:"method,omitempty"`
}

func (o *ConfigSmtp) GetUser() string {
	if o == nil {
		o = &ConfigSmtp{}
	}

	return o.User
}

func (o *ConfigSmtp) GetPassword() string {
	if o == nil {
		o = &ConfigSmtp{}
	}

	return o.Password
}

func (o *ConfigSmtp) GetSender() string {
	if o == nil {
		o = &ConfigSmtp{}
	}

	return o.Sender
}

func (o *ConfigSmtp) GetHost() string {
	if o == nil {
		o = &ConfigSmtp{}
	}

	return o.Host
}

func (o *ConfigSmtp) GetPort() uint16 {
	if o == nil {
		o = &ConfigSmtp{}
	}

	return o.Port
}

func (o *ConfigSmtp) GetSecure() bool {
	if o == nil {
		o = &ConfigSmtp{}
	}

	return o.Secure
}

func (o *ConfigSmtp) GetMethod() string {
	if o == nil {
		o = &ConfigSmtp{}
	}

	return o.Method
}

type ConfigSmtpUpdateInput struct {
	User     *string `json:"user,omitempty"`
	Password *string `json:"password,omitempty"`
	Sender   *string `json:"sender,omitempty"`
	Host     *string `json:"host,omitempty"`
	Port     *uint16 `json:"port,omitempty"`
	Secure   *bool   `json:"secure,omitempty"`
	Method   *string `json:"method,omitempty"`
}

func (s *ConfigSmtp) Update(v *ConfigSmtpUpdateInput) {
	if v == nil {
		return
	}
	if v.User != nil {
		s.User = *v.User
	}
	if v.Password != nil {
		s.Password = *v.Password
	}
	if v.Sender != nil {
		s.Sender = *v.Sender
	}
	if v.Host != nil {
		s.Host = *v.Host
	}
	if v.Port != nil {
		s.Port = *v.Port
	}
	if v.Secure != nil {
		s.Secure = *v.Secure
	}
	if v.Method != nil {
		s.Method = *v.Method
	}
}

type ConfigSmtpInsertInput struct {
	User     string  `json:"user,omitempty"`
	Password string  `json:"password,omitempty"`
	Sender   *string `json:"sender,omitempty"`
	Host     string  `json:"host,omitempty"`
	Port     *uint16 `json:"port,omitempty"`
	Secure   *bool   `json:"secure,omitempty"`
	Method   *string `json:"method,omitempty"`
}

func (s *ConfigSmtp) Insert(v *ConfigSmtpInsertInput) {
	s.User = v.User
	s.Password = v.Password
	if v.Sender != nil {
		s.Sender = *v.Sender
	}
	s.Host = v.Host
	if v.Port != nil {
		s.Port = *v.Port
	}
	if v.Secure != nil {
		s.Secure = *v.Secure
	}
	if v.Method != nil {
		s.Method = *v.Method
	}
}

func (s *ConfigSmtp) Clone() *ConfigSmtp {
	if s == nil {
		return nil
	}

	v := &ConfigSmtp{}
	v.User = s.User
	v.Password = s.Password
	v.Sender = s.Sender
	v.Host = s.Host
	v.Port = s.Port
	v.Secure = s.Secure
	v.Method = s.Method
	return v
}

type ConfigSmtpComparisonExp struct {
	And      []*ConfigSmtpComparisonExp  `json:"_and,omitempty"`
	Not      *ConfigSmtpComparisonExp    `json:"_not,omitempty"`
	Or       []*ConfigSmtpComparisonExp  `json:"_or,omitempty"`
	User     *ConfigStringComparisonExp  `json:"user,omitempty"`
	Password *ConfigStringComparisonExp  `json:"password,omitempty"`
	Sender   *ConfigStringComparisonExp  `json:"sender,omitempty"`
	Host     *ConfigStringComparisonExp  `json:"host,omitempty"`
	Port     *ConfigPortComparisonExp    `json:"port,omitempty"`
	Secure   *ConfigBooleanComparisonExp `json:"secure,omitempty"`
	Method   *ConfigStringComparisonExp  `json:"method,omitempty"`
}

func (exp *ConfigSmtpComparisonExp) Matches(o *ConfigSmtp) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSmtp{}
	}
	if !exp.User.Matches(o.User) {
		return false
	}
	if !exp.Password.Matches(o.Password) {
		return false
	}
	if !exp.Sender.Matches(o.Sender) {
		return false
	}
	if !exp.Host.Matches(o.Host) {
		return false
	}
	if !exp.Port.Matches(o.Port) {
		return false
	}
	if !exp.Secure.Matches(o.Secure) {
		return false
	}
	if !exp.Method.Matches(o.Method) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigStandardOauthProvider struct {
	Enabled      bool     `json:"enabled,omitempty"`
	ClientId     string   `json:"clientId,omitempty"`
	Scope        []string `json:"scope,omitempty"`
	ClientSecret string   `json:"clientSecret,omitempty"`
}

func (o *ConfigStandardOauthProvider) GetEnabled() bool {
	if o == nil {
		o = &ConfigStandardOauthProvider{}
	}

	return o.Enabled
}

func (o *ConfigStandardOauthProvider) GetClientId() string {
	if o == nil {
		o = &ConfigStandardOauthProvider{}
	}

	return o.ClientId
}

func (o *ConfigStandardOauthProvider) GetScope() []string {
	if o == nil {
		o = &ConfigStandardOauthProvider{}
	}

	return o.Scope
}

func (o *ConfigStandardOauthProvider) GetClientSecret() string {
	if o == nil {
		o = &ConfigStandardOauthProvider{}
	}

	return o.ClientSecret
}

type ConfigStandardOauthProviderUpdateInput struct {
	Enabled      *bool    `json:"enabled,omitempty"`
	ClientId     *string  `json:"clientId,omitempty"`
	Scope        []string `json:"scope,omitempty"`
	ClientSecret *string  `json:"clientSecret,omitempty"`
}

func (s *ConfigStandardOauthProvider) Update(v *ConfigStandardOauthProviderUpdateInput) {
	if v == nil {
		return
	}
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
	if v.ClientId != nil {
		s.ClientId = *v.ClientId
	}
	if v.Scope != nil {
		s.Scope = make([]string, len(v.Scope))
		for i, e := range v.Scope {
			s.Scope[i] = e
		}
	}
	if v.ClientSecret != nil {
		s.ClientSecret = *v.ClientSecret
	}
}

type ConfigStandardOauthProviderInsertInput struct {
	Enabled      *bool    `json:"enabled,omitempty"`
	ClientId     *string  `json:"clientId,omitempty"`
	Scope        []string `json:"scope,omitempty"`
	ClientSecret *string  `json:"clientSecret,omitempty"`
}

func (s *ConfigStandardOauthProvider) Insert(v *ConfigStandardOauthProviderInsertInput) {
	if v.Enabled != nil {
		s.Enabled = *v.Enabled
	}
	if v.ClientId != nil {
		s.ClientId = *v.ClientId
	}
	if v.Scope != nil {
		s.Scope = make([]string, len(v.Scope))
		for i, e := range v.Scope {
			s.Scope[i] = e
		}
	}
	if v.ClientSecret != nil {
		s.ClientSecret = *v.ClientSecret
	}
}

func (s *ConfigStandardOauthProvider) Clone() *ConfigStandardOauthProvider {
	if s == nil {
		return nil
	}

	v := &ConfigStandardOauthProvider{}
	v.Enabled = s.Enabled
	v.ClientId = s.ClientId
	v.Scope = make([]string, len(s.Scope))
	copy(v.Scope, s.Scope)
	v.ClientSecret = s.ClientSecret
	return v
}

type ConfigStandardOauthProviderComparisonExp struct {
	And          []*ConfigStandardOauthProviderComparisonExp `json:"_and,omitempty"`
	Not          *ConfigStandardOauthProviderComparisonExp   `json:"_not,omitempty"`
	Or           []*ConfigStandardOauthProviderComparisonExp `json:"_or,omitempty"`
	Enabled      *ConfigBooleanComparisonExp                 `json:"enabled,omitempty"`
	ClientId     *ConfigStringComparisonExp                  `json:"clientId,omitempty"`
	Scope        *ConfigStringComparisonExp                  `json:"scope,omitempty"`
	ClientSecret *ConfigStringComparisonExp                  `json:"clientSecret,omitempty"`
}

func (exp *ConfigStandardOauthProviderComparisonExp) Matches(o *ConfigStandardOauthProvider) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigStandardOauthProvider{
			Scope: []string{},
		}
	}
	if !exp.Enabled.Matches(o.Enabled) {
		return false
	}
	if !exp.ClientId.Matches(o.ClientId) {
		return false
	}
	{
		found := false
		for _, o := range o.Scope {
			if exp.Scope.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Scope != nil {
			return false
		}
	}
	if !exp.ClientSecret.Matches(o.ClientSecret) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigStorage struct {
	Version string `json:"version,omitempty"`
}

func (o *ConfigStorage) GetVersion() string {
	if o == nil {
		o = &ConfigStorage{}
	}

	return o.Version
}

type ConfigStorageUpdateInput struct {
	Version *string `json:"version,omitempty"`
}

func (s *ConfigStorage) Update(v *ConfigStorageUpdateInput) {
	if v == nil {
		return
	}
	if v.Version != nil {
		s.Version = *v.Version
	}
}

type ConfigStorageInsertInput struct {
	Version *string `json:"version,omitempty"`
}

func (s *ConfigStorage) Insert(v *ConfigStorageInsertInput) {
	if v.Version != nil {
		s.Version = *v.Version
	}
}

func (s *ConfigStorage) Clone() *ConfigStorage {
	if s == nil {
		return nil
	}

	v := &ConfigStorage{}
	v.Version = s.Version
	return v
}

type ConfigStorageComparisonExp struct {
	And     []*ConfigStorageComparisonExp `json:"_and,omitempty"`
	Not     *ConfigStorageComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigStorageComparisonExp `json:"_or,omitempty"`
	Version *ConfigStringComparisonExp    `json:"version,omitempty"`
}

func (exp *ConfigStorageComparisonExp) Matches(o *ConfigStorage) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigStorage{}
	}
	if !exp.Version.Matches(o.Version) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSystemConfig struct {
	Auth     *ConfigSystemConfigAuth     `json:"auth,omitempty"`
	Postgres *ConfigSystemConfigPostgres `json:"postgres,omitempty"`
}

func (o *ConfigSystemConfig) GetAuth() *ConfigSystemConfigAuth {
	if o == nil {
		return nil
	}

	return o.Auth
}

func (o *ConfigSystemConfig) GetPostgres() *ConfigSystemConfigPostgres {
	if o == nil {
		return nil
	}

	return o.Postgres
}

type ConfigSystemConfigUpdateInput struct {
	Auth     *ConfigSystemConfigAuthUpdateInput     `json:"auth,omitempty"`
	Postgres *ConfigSystemConfigPostgresUpdateInput `json:"postgres,omitempty"`
}

func (s *ConfigSystemConfig) Update(v *ConfigSystemConfigUpdateInput) {
	if v == nil {
		return
	}
	if v.Auth != nil {
		if s.Auth == nil {
			s.Auth = &ConfigSystemConfigAuth{}
		}
		s.Auth.Update(v.Auth)
	}
	if v.Postgres != nil {
		if s.Postgres == nil {
			s.Postgres = &ConfigSystemConfigPostgres{}
		}
		s.Postgres.Update(v.Postgres)
	}
}

type ConfigSystemConfigInsertInput struct {
	Auth     *ConfigSystemConfigAuthInsertInput     `json:"auth,omitempty"`
	Postgres *ConfigSystemConfigPostgresInsertInput `json:"postgres,omitempty"`
}

func (s *ConfigSystemConfig) Insert(v *ConfigSystemConfigInsertInput) {
	if v.Auth != nil {
		if s.Auth == nil {
			s.Auth = &ConfigSystemConfigAuth{}
		}
		s.Auth.Insert(v.Auth)
	}
	if v.Postgres != nil {
		if s.Postgres == nil {
			s.Postgres = &ConfigSystemConfigPostgres{}
		}
		s.Postgres.Insert(v.Postgres)
	}
}

func (s *ConfigSystemConfig) Clone() *ConfigSystemConfig {
	if s == nil {
		return nil
	}

	v := &ConfigSystemConfig{}
	v.Auth = s.Auth.Clone()
	v.Postgres = s.Postgres.Clone()
	return v
}

type ConfigSystemConfigComparisonExp struct {
	And      []*ConfigSystemConfigComparisonExp       `json:"_and,omitempty"`
	Not      *ConfigSystemConfigComparisonExp         `json:"_not,omitempty"`
	Or       []*ConfigSystemConfigComparisonExp       `json:"_or,omitempty"`
	Auth     *ConfigSystemConfigAuthComparisonExp     `json:"auth,omitempty"`
	Postgres *ConfigSystemConfigPostgresComparisonExp `json:"postgres,omitempty"`
}

func (exp *ConfigSystemConfigComparisonExp) Matches(o *ConfigSystemConfig) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSystemConfig{
			Auth:     &ConfigSystemConfigAuth{},
			Postgres: &ConfigSystemConfigPostgres{},
		}
	}
	if !exp.Auth.Matches(o.Auth) {
		return false
	}
	if !exp.Postgres.Matches(o.Postgres) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSystemConfigAuth struct {
	Email *ConfigSystemConfigAuthEmail `json:"email,omitempty"`
}

func (o *ConfigSystemConfigAuth) GetEmail() *ConfigSystemConfigAuthEmail {
	if o == nil {
		return nil
	}

	return o.Email
}

type ConfigSystemConfigAuthUpdateInput struct {
	Email *ConfigSystemConfigAuthEmailUpdateInput `json:"email,omitempty"`
}

func (s *ConfigSystemConfigAuth) Update(v *ConfigSystemConfigAuthUpdateInput) {
	if v == nil {
		return
	}
	if v.Email != nil {
		if s.Email == nil {
			s.Email = &ConfigSystemConfigAuthEmail{}
		}
		s.Email.Update(v.Email)
	}
}

type ConfigSystemConfigAuthInsertInput struct {
	Email *ConfigSystemConfigAuthEmailInsertInput `json:"email,omitempty"`
}

func (s *ConfigSystemConfigAuth) Insert(v *ConfigSystemConfigAuthInsertInput) {
	if v.Email != nil {
		if s.Email == nil {
			s.Email = &ConfigSystemConfigAuthEmail{}
		}
		s.Email.Insert(v.Email)
	}
}

func (s *ConfigSystemConfigAuth) Clone() *ConfigSystemConfigAuth {
	if s == nil {
		return nil
	}

	v := &ConfigSystemConfigAuth{}
	v.Email = s.Email.Clone()
	return v
}

type ConfigSystemConfigAuthComparisonExp struct {
	And   []*ConfigSystemConfigAuthComparisonExp    `json:"_and,omitempty"`
	Not   *ConfigSystemConfigAuthComparisonExp      `json:"_not,omitempty"`
	Or    []*ConfigSystemConfigAuthComparisonExp    `json:"_or,omitempty"`
	Email *ConfigSystemConfigAuthEmailComparisonExp `json:"email,omitempty"`
}

func (exp *ConfigSystemConfigAuthComparisonExp) Matches(o *ConfigSystemConfigAuth) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSystemConfigAuth{
			Email: &ConfigSystemConfigAuthEmail{},
		}
	}
	if !exp.Email.Matches(o.Email) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSystemConfigAuthEmail struct {
	Templates *ConfigSystemConfigAuthEmailTemplates `json:"templates,omitempty"`
}

func (o *ConfigSystemConfigAuthEmail) GetTemplates() *ConfigSystemConfigAuthEmailTemplates {
	if o == nil {
		return nil
	}

	return o.Templates
}

type ConfigSystemConfigAuthEmailUpdateInput struct {
	Templates *ConfigSystemConfigAuthEmailTemplatesUpdateInput `json:"templates,omitempty"`
}

func (s *ConfigSystemConfigAuthEmail) Update(v *ConfigSystemConfigAuthEmailUpdateInput) {
	if v == nil {
		return
	}
	if v.Templates != nil {
		if s.Templates == nil {
			s.Templates = &ConfigSystemConfigAuthEmailTemplates{}
		}
		s.Templates.Update(v.Templates)
	}
}

type ConfigSystemConfigAuthEmailInsertInput struct {
	Templates *ConfigSystemConfigAuthEmailTemplatesInsertInput `json:"templates,omitempty"`
}

func (s *ConfigSystemConfigAuthEmail) Insert(v *ConfigSystemConfigAuthEmailInsertInput) {
	if v.Templates != nil {
		if s.Templates == nil {
			s.Templates = &ConfigSystemConfigAuthEmailTemplates{}
		}
		s.Templates.Insert(v.Templates)
	}
}

func (s *ConfigSystemConfigAuthEmail) Clone() *ConfigSystemConfigAuthEmail {
	if s == nil {
		return nil
	}

	v := &ConfigSystemConfigAuthEmail{}
	v.Templates = s.Templates.Clone()
	return v
}

type ConfigSystemConfigAuthEmailComparisonExp struct {
	And       []*ConfigSystemConfigAuthEmailComparisonExp        `json:"_and,omitempty"`
	Not       *ConfigSystemConfigAuthEmailComparisonExp          `json:"_not,omitempty"`
	Or        []*ConfigSystemConfigAuthEmailComparisonExp        `json:"_or,omitempty"`
	Templates *ConfigSystemConfigAuthEmailTemplatesComparisonExp `json:"templates,omitempty"`
}

func (exp *ConfigSystemConfigAuthEmailComparisonExp) Matches(o *ConfigSystemConfigAuthEmail) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSystemConfigAuthEmail{
			Templates: &ConfigSystemConfigAuthEmailTemplates{},
		}
	}
	if !exp.Templates.Matches(o.Templates) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSystemConfigAuthEmailTemplates struct {
	S3Key string `json:"s3Key,omitempty"`
}

func (o *ConfigSystemConfigAuthEmailTemplates) GetS3Key() string {
	if o == nil {
		o = &ConfigSystemConfigAuthEmailTemplates{}
	}

	return o.S3Key
}

type ConfigSystemConfigAuthEmailTemplatesUpdateInput struct {
	S3Key *string `json:"s3Key,omitempty"`
}

func (s *ConfigSystemConfigAuthEmailTemplates) Update(v *ConfigSystemConfigAuthEmailTemplatesUpdateInput) {
	if v == nil {
		return
	}
	if v.S3Key != nil {
		s.S3Key = *v.S3Key
	}
}

type ConfigSystemConfigAuthEmailTemplatesInsertInput struct {
	S3Key *string `json:"s3Key,omitempty"`
}

func (s *ConfigSystemConfigAuthEmailTemplates) Insert(v *ConfigSystemConfigAuthEmailTemplatesInsertInput) {
	if v.S3Key != nil {
		s.S3Key = *v.S3Key
	}
}

func (s *ConfigSystemConfigAuthEmailTemplates) Clone() *ConfigSystemConfigAuthEmailTemplates {
	if s == nil {
		return nil
	}

	v := &ConfigSystemConfigAuthEmailTemplates{}
	v.S3Key = s.S3Key
	return v
}

type ConfigSystemConfigAuthEmailTemplatesComparisonExp struct {
	And   []*ConfigSystemConfigAuthEmailTemplatesComparisonExp `json:"_and,omitempty"`
	Not   *ConfigSystemConfigAuthEmailTemplatesComparisonExp   `json:"_not,omitempty"`
	Or    []*ConfigSystemConfigAuthEmailTemplatesComparisonExp `json:"_or,omitempty"`
	S3Key *ConfigStringComparisonExp                           `json:"s3Key,omitempty"`
}

func (exp *ConfigSystemConfigAuthEmailTemplatesComparisonExp) Matches(o *ConfigSystemConfigAuthEmailTemplates) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSystemConfigAuthEmailTemplates{}
	}
	if !exp.S3Key.Matches(o.S3Key) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSystemConfigPostgres struct {
	Version            string                            `json:"version,omitempty"`
	ConnectionSettings *ConfigPostgresConnectionSettings `json:"connectionSettings,omitempty"`
}

func (o *ConfigSystemConfigPostgres) GetVersion() string {
	if o == nil {
		o = &ConfigSystemConfigPostgres{}
	}

	return o.Version
}

func (o *ConfigSystemConfigPostgres) GetConnectionSettings() *ConfigPostgresConnectionSettings {
	if o == nil {
		return nil
	}

	return o.ConnectionSettings
}

type ConfigSystemConfigPostgresUpdateInput struct {
	Version            *string                                      `json:"version,omitempty"`
	ConnectionSettings *ConfigPostgresConnectionSettingsUpdateInput `json:"connectionSettings,omitempty"`
}

func (s *ConfigSystemConfigPostgres) Update(v *ConfigSystemConfigPostgresUpdateInput) {
	if v == nil {
		return
	}
	if v.Version != nil {
		s.Version = *v.Version
	}
	if v.ConnectionSettings != nil {
		if s.ConnectionSettings == nil {
			s.ConnectionSettings = &ConfigPostgresConnectionSettings{}
		}
		s.ConnectionSettings.Update(v.ConnectionSettings)
	}
}

type ConfigSystemConfigPostgresInsertInput struct {
	Version            string                                       `json:"version,omitempty"`
	ConnectionSettings *ConfigPostgresConnectionSettingsInsertInput `json:"connectionSettings,omitempty"`
}

func (s *ConfigSystemConfigPostgres) Insert(v *ConfigSystemConfigPostgresInsertInput) {
	s.Version = v.Version
	if v.ConnectionSettings != nil {
		if s.ConnectionSettings == nil {
			s.ConnectionSettings = &ConfigPostgresConnectionSettings{}
		}
		s.ConnectionSettings.Insert(v.ConnectionSettings)
	}
}

func (s *ConfigSystemConfigPostgres) Clone() *ConfigSystemConfigPostgres {
	if s == nil {
		return nil
	}

	v := &ConfigSystemConfigPostgres{}
	v.Version = s.Version
	v.ConnectionSettings = s.ConnectionSettings.Clone()
	return v
}

type ConfigSystemConfigPostgresComparisonExp struct {
	And                []*ConfigSystemConfigPostgresComparisonExp     `json:"_and,omitempty"`
	Not                *ConfigSystemConfigPostgresComparisonExp       `json:"_not,omitempty"`
	Or                 []*ConfigSystemConfigPostgresComparisonExp     `json:"_or,omitempty"`
	Version            *ConfigStringComparisonExp                     `json:"version,omitempty"`
	ConnectionSettings *ConfigPostgresConnectionSettingsComparisonExp `json:"connectionSettings,omitempty"`
}

func (exp *ConfigSystemConfigPostgresComparisonExp) Matches(o *ConfigSystemConfigPostgres) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSystemConfigPostgres{
			ConnectionSettings: &ConfigPostgresConnectionSettings{},
		}
	}
	if !exp.Version.Matches(o.Version) {
		return false
	}
	if !exp.ConnectionSettings.Matches(o.ConnectionSettings) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigUrlComparisonExp struct {
	Eq  *string  `json:"_eq,omitempty"`
	Neq *string  `json:"_neq,omitempty"`
	In  []string `json:"_in,omitempty"`
	Nin []string `json:"_nin,omitempty"`
}

func (exp *ConfigUrlComparisonExp) Matches(o string) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}

type ConfigUserRoleComparisonExp struct {
	Eq  *string  `json:"_eq,omitempty"`
	Neq *string  `json:"_neq,omitempty"`
	In  []string `json:"_in,omitempty"`
	Nin []string `json:"_nin,omitempty"`
}

func (exp *ConfigUserRoleComparisonExp) Matches(o string) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}
